<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端-洋仔</title>
  <subtitle>专注于前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://html-js.site/"/>
  <updated>2017-09-09T07:19:40.000Z</updated>
  <id>http://html-js.site/</id>
  
  <author>
    <name>wangyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript进阶-惰性函数</title>
    <link href="http://html-js.site/2017/09/09/javascript%E8%BF%9B%E9%98%B6-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    <id>http://html-js.site/2017/09/09/javascript进阶-惰性函数/</id>
    <published>2017-09-09T07:15:03.000Z</published>
    <updated>2017-09-09T07:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>函数是js世界的一等公民，js的动态性、易变性在函数的应用上，体现的淋漓尽致。做为参数，做为返回值等，正是函数这些特性，使得js开发变的有趣。</p>
</blockquote>
<p>下面就阐述一下，js一个有趣的应用–惰性函数定义（Lazy Function Definition）。</p>
<p>惰性载入表示函数执行的分支只会在函数第一次掉用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。</p>
<p>下面我们看几个典型的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">        element.addEventListener(type, fun, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">        element.attachEvent(<span class="string">'on'</span> + type, fun);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        element[<span class="string">'on'</span> + type] = fun;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是注册函数监听的各浏览器兼容函数。由于，各浏览之间的差异，不得不在用的时候做能力检测。显然，单从功能上讲，已经做到了兼容浏览器。美中不足，每次绑定监听，都会对能力做一次检测。然而，真正的应用中，这显然是多余的，同一个应用环境中，其实只需要检测一次即可。</p>
<p>下面我们重写上面的addEvent：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">            element.addEventListener(type, fun, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">            element.attachEvent(<span class="string">'on'</span> + type, fun);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = fun;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addEvent(type, element, fun);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由上，第一次调用addEvent会对浏览器做能力检测，然后，重写了addEvent。下次再调用的时候，由于函数被重写，不会再做能力检测。</p>
<p>同样的应用，javascript高级程序设计里的一例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</div><div class="line">            <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</div><div class="line">                            <span class="string">"MSXML2.XMLHttp"</span>];</div><div class="line">    </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</div><div class="line">                    <span class="built_in">arguments</span>.callee.activeXString = versions[i];</div><div class="line">                    <span class="keyword">return</span> xhr;</div><div class="line">                &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">                    <span class="comment">//skip</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很显然，惰性函数在这里优势更加明显，因为这里有更多的分支。下面我们看一下重写后台的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>) &#123;</div><div class="line">        createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> curxhr;</div><div class="line">        <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</div><div class="line">            <span class="string">"MSXML2.XMLHttp"</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = versions.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</div><div class="line">                curxhr = versions[i];</div><div class="line">                createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(curxhr);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> xhr;</div><div class="line">            &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">                <span class="comment">//skip</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>浏览器之间最大的差异，莫过于Dom操作，Dom操作也是前端应用 中最频繁的操作，前端的大多性能提升，均体现在Dom操作方面。下面看一个Dom操作方面的惰性函数定义例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.pageYOffset == <span class="string">'number'</span>) &#123;</div><div class="line"></div><div class="line">        getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">window</span>.pageYOffset;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">typeof</span> <span class="built_in">document</span>.compatMode == <span class="string">'string'</span>) &amp;&amp;</div><div class="line">               (<span class="built_in">document</span>.compatMode.indexOf(<span class="string">'CSS'</span>) &gt;= <span class="number">0</span>) &amp;&amp;</div><div class="line">               (<span class="built_in">document</span>.documentElement) &amp;&amp;</div><div class="line">               (<span class="keyword">typeof</span> <span class="built_in">document</span>.documentElement.scrollTop == <span class="string">'number'</span>)) &#123;</div><div class="line"></div><div class="line">        getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">document</span>.body) &amp;&amp;</div><div class="line">               (<span class="keyword">typeof</span> <span class="built_in">document</span>.body.scrollTop == <span class="string">'number'</span>)) &#123;</div><div class="line"></div><div class="line">      getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="built_in">document</span>.body.scrollTop;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">NaN</span>;</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> getScrollY();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>惰性函数定义应用还体现在创建单例上：(目前还不清楚创建单例的话有什么好处)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">unction Universe() &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存的实例</span></div><div class="line">    <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 其它内容</span></div><div class="line">    <span class="keyword">this</span>.start_time = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 重写构造函数</span></div><div class="line">    Universe = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，像上面这种例子有很多。惰性函数定义，应用场景我们可以总结一下：</p>
<p>1 应用频繁，如果只用一次，是体现不出它的优点出来的，用的次数越多，越能体现这种模式的优势所在；</p>
<p>2 固定不变，一次判定，在固定的应用环境中不会发生改变；</p>
<p>3 复杂的分支判断，没有差异性，不需要应用这种模式；</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数是js世界的一等公民，js的动态性、易变性在函数的应用上，体现的淋漓尽致。做为参数，做为返回值等，正是函数这些特性，使得js开发变的有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面就阐述一下，js一个有趣的应用–惰性函数定义（Lazy F
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="javascript进阶" scheme="http://html-js.site/tags/javascript%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>react-router 按需加载</title>
    <link href="http://html-js.site/2017/09/09/react-router-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/"/>
    <id>http://html-js.site/2017/09/09/react-router-按需加载/</id>
    <published>2017-09-08T16:54:49.000Z</published>
    <updated>2017-09-08T17:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文使用的 react-router 版本为 2.8.1</p>
</blockquote>
<p>React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</p>
<p>效果：<br>以前是这样：<br><img src="/images/page/reactRouter/01.png" alt=""></p>
<p>现在是这样：<img src="/images/page/reactRouter/02.png" alt=""></p>
<p>实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。</p>
<p>下面是改造过程</p>
<h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><p>首先在 <code>webpack.config.js</code> 的 <code>output</code> 内加上 <code>chunkFilename</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'app.js'</span>,</div><div class="line">    <span class="attr">publicPath</span>: defaultSettings.publicPath,</div><div class="line">    <span class="comment">// 添加 chunkFilename</span></div><div class="line">    chunkFilename: <span class="string">'[name].[chunkhash:5].chunk.js'</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><code>name</code> 是在代码里为创建的 <code>chunk</code> 指定的名字，如果代码中没指定则 <code>webpack</code> 默认分配 <code>id</code> 作为 <code>name</code>。</p>
<p><code>chunkhash</code> 是文件的 <code>hash</code> 码，这里只使用前五位。</p>
<h2 id="添加首页"><a href="#添加首页" class="headerlink" title="添加首页"></a>添加首页</h2><p>以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  (</div><div class="line">    &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">      &#123;/* 主页 */&#125;</div><div class="line">      &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">        &#123;/* 默认 */&#125;</div><div class="line">        &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class="line"></div><div class="line">        &#123;/* baidu */&#125;</div><div class="line">        &lt;Route path="/baidu" component=&#123;BaiduPage&#125;&gt;</div><div class="line">          &lt;Route path="result" component=&#123;BaiduResultPage&#125; /&gt;</div><div class="line">          &lt;Route path="frequency" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line"></div><div class="line">        &#123;/* 404 */&#125;</div><div class="line">        &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class="line">        </div><div class="line">        &#123;/* 其他重定向到 404 */&#125;</div><div class="line">        &lt;Redirect from='*' to='/404' /&gt;</div><div class="line">      &lt;/Route&gt;</div><div class="line">    &lt;/Router&gt;</div><div class="line">  ), document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>按需加载之后，我们需要让路由动态加载组件，需要将 <code>component</code> 换成 <code>getComponent</code>。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 <code>rootRoute</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> rootRoute = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">  <span class="attr">indexRoute</span>: &#123;</div><div class="line">    getComponent(nextState, cb) &#123;</div><div class="line">      <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/HomePage'</span>))</div><div class="line">      &#125;, <span class="string">'HomePage'</span>)</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/Main'</span>))</div><div class="line">    &#125;, <span class="string">'Main'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">childRoutes</span>: [</div><div class="line">    <span class="built_in">require</span>(<span class="string">'./routes/baidu'</span>),</div><div class="line">    <span class="built_in">require</span>(<span class="string">'./routes/404'</span>),</div><div class="line">    <span class="built_in">require</span>(<span class="string">'./routes/redirect'</span>)</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  (</div><div class="line">    &lt;Router</div><div class="line">      history=&#123;browserHistory&#125;</div><div class="line">      routes=&#123;rootRoute&#125;</div><div class="line">      /&gt;</div><div class="line">  ), document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><code>history</code> 不变，在 <code>Router</code> 中添加 <code>routes</code> 属性，将创建的路由传递进去。</p>
<p>这里有四个属性：</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>将匹配的路由，也就是以前的 path。</p>
<h3 id="getComponent"><a href="#getComponent" class="headerlink" title="getComponent"></a>getComponent</h3><p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。</p>
<p>这里面有个 <strong>require.ensure</strong> 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure(dependencies, callback, chunkName)</div></pre></td></tr></table></figure></p>
<p>这是 <code>webpack</code> 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 <code>chunkName</code>，用来指定这个 <code>chunk file</code> 的 <code>name</code>。</p>
<p>如果需要返回多个子组件，则使用 <code>getComponents</code> 方法，将多个组件作为一个对象的属性通过 <code>cb</code> 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 <code>getComponent</code>。</p>
<h3 id="indexRoute"><a href="#indexRoute" class="headerlink" title="indexRoute"></a>indexRoute</h3><p>用来设置主页，对应于以前的 <code>&lt;IndexRoute&gt;</code>。</p>
<p>注意这里的 <code>indexRoute</code> 写法， <strong>这是个对象，在对象里面使用 getComponent</strong>。</p>
<h3 id="childRoutes"><a href="#childRoutes" class="headerlink" title="childRoutes"></a>childRoutes</h3><p>这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 <code>/baidu</code>、<code>/404</code> 和 <code>*</code> 都拆了出来，接下来将分别为他们创建路由配置。</p>
<h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>上面的 <code>childRoutes</code> 里面，我们 <code>require</code> 了三个子路由，在目录下创建 <code>routes</code> 目录，将这三个路由放置进去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">routes/</div><div class="line">├── <span class="number">404</span></div><div class="line">│   └── index.js</div><div class="line">├── baidu</div><div class="line">│   ├── index.js</div><div class="line">│   └── routes</div><div class="line">│       ├── frequency</div><div class="line">│       │   └── index.js</div><div class="line">│       └── result</div><div class="line">│           └── index.js</div><div class="line">└── redirect</div><div class="line">    └── index.js</div></pre></td></tr></table></figure>
<p>和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：</p>
<h3 id="404-index-js"><a href="#404-index-js" class="headerlink" title="/404/index.js"></a>/404/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'404'</span>,</div><div class="line"></div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/NotFoundPage'</span>))</div><div class="line">    &#125;, <span class="string">'NotFoundPage'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>/baidu/index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'baidu'</span>,</div><div class="line"></div><div class="line">  getChildRoutes(partialNextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, [</div><div class="line">        <span class="built_in">require</span>(<span class="string">'./routes/result'</span>),</div><div class="line">        <span class="built_in">require</span>(<span class="string">'./routes/frequency'</span>)</div><div class="line">      ])</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/BaiduPage'</span>))</div><div class="line">    &#125;, <span class="string">'BaiduPage'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="baidu-routes-frequency-index-js"><a href="#baidu-routes-frequency-index-js" class="headerlink" title="/baidu/routes/frequency/index.js"></a>/baidu/routes/frequency/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'frequency'</span>,</div><div class="line"></div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/BaiduFrequencyPage'</span>))</div><div class="line">    &#125;, <span class="string">'BaiduFrequencyPage'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。</p>
<h2 id="设置-Redirect"><a href="#设置-Redirect" class="headerlink" title="设置 Redirect"></a>设置 Redirect</h2><p>之前我们在根路由下是这么设置重定向的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">    &#123;/* home */&#125;</div><div class="line">    &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class="line"></div><div class="line">    &lt;Route path="/baidu" component=&#123;BaiduPage&#125;&gt;</div><div class="line">        &lt;Route path="result" component=&#123;BaiduResultPage&#125; /&gt;</div><div class="line">        &lt;Route path="frequency" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line"></div><div class="line">    &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class="line">    &#123;/* 如果都不匹配，重定向到 404 */&#125;</div><div class="line">    &lt;Redirect from='*' to='/404' /&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>当改写之后，我们需要把这个重定向的路由单独拆出来，也就是 * 这个路由，我们上面已经为他创建了一个 <code>redirect</code> 目录。这里使用到 <code>onEnter</code> 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 <code>redirect</code> ：</p>
<h3 id="redirect-index-js"><a href="#redirect-index-js" class="headerlink" title="/redirect/index.js"></a>/redirect/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'*'</span>,</div><div class="line">  <span class="attr">onEnter</span>: <span class="function">(<span class="params">_, replaceState</span>) =&gt;</span> replaceState(<span class="literal">null</span>, <span class="string">"/404"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-root-route-must-render-a-single-element"><a href="#The-root-route-must-render-a-single-element" class="headerlink" title="The root route must render a single element"></a>The root route must render a single element</h2><p>跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 <strong>The root route must render a single element</strong> 这个异常，这是因为 <code>module.exports</code> 和 ES6 里的 <code>export default</code> 有区别。</p>
<p>如果你是使用 <code>es6</code> 的写法，也就是你的组件都是通过 <code>export default</code> 导出的，那么在 <code>getComponent</code> 方法里面需要加入 <code>.default</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      <span class="comment">// 在后面加 .default</span></div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/ReportPage'</span>)).default</div><div class="line">    &#125;, <span class="string">'ReportPage'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你是使用 <code>CommonJS</code> 的写法，也就是通过 <code>module.exports</code> 导出的，那就无须加 <code>.default</code> 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文使用的 react-router 版本为 2.8.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
      <category term="react-router" scheme="http://html-js.site/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>React和Redux的连接react-redux</title>
    <link href="http://html-js.site/2017/09/02/React%E5%92%8CRedux%E7%9A%84%E8%BF%9E%E6%8E%A5react-redux/"/>
    <id>http://html-js.site/2017/09/02/React和Redux的连接react-redux/</id>
    <published>2017-09-02T02:45:57.000Z</published>
    <updated>2017-09-02T03:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/" target="_blank" rel="external">http://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/</a></p>
</blockquote>
<p>Redux本身和React并没有之间的关联，它是一个通用Javscript App模块，用做App State的管理。要在React的项目中使用Redux，比较好的方式是借助react-redux这个库来做连接，这里的意思是，并不是没有react-redux，这两个库就不弄一起用了，而是说react-redux提供了一些封装，一种更科学的代码组织方式，让我们更舒服地在React的代码中使用Redux。</p>
<p>之前仅通过Redux文档来了解react-redux，在一段时间的实践后准备翻一翻源代码，顺便做些相关的总结。我看的代码的npm版本为<code>v4.0.0</code>，也就是说使用的React版本是<code>v0.14.x</code>。</p>
<p>react-redux提供两个关键模块：Provider和connect。</p>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider这个模块是作为整个App的容器，在你原有的App Container的基础上再包上一层，它的工作很简单，就是接受Redux的store作为props，并将其声明为context的属性之一，子组件可以在声明了<code>contextTypes</code>之后可以方便的通过<code>this.context.store</code>访问到store。不过我们的组件通常不需要这么做，将store放在context里，是为了给下面的connect用的。</p>
<p>这个是Provider的使用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// config app root</span></div><div class="line"><span class="keyword">const</span> history = createHistory()  </div><div class="line"><span class="keyword">const</span> root = (  </div><div class="line">  &lt;Provider store=&#123;store&#125; key="provider"&gt;</div><div class="line">    &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; /&gt;</div><div class="line">  &lt;/Provider&gt;</div><div class="line">)</div><div class="line"></div><div class="line">// render</div><div class="line">ReactDOM.render(  </div><div class="line">  root,</div><div class="line">  document.getElementById('root')</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>这个模块是算是真正意义上连接了Redux和React，正好它的名字也叫connect。</p>
<p>先考虑Redux是怎么运作的：首先store中维护了一个state，我们dispatch一个action，接下来reducer根据这个action更新state。</p>
<p>映射到我们的React应用中，store中维护的state就是我们的app state，一个React组件作为View层，做两件事：render和响应用户操作。于是connect就是将store中的必要数据作为props传递给React组件来render，并包装action creator用于在响应用户操作时dispatch一个action。</p>
<p>好了，详细看看connect这个模块做了什么。先从它的使用来说，它的API如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</div></pre></td></tr></table></figure></p>
<p>mapStateToProps是一个函数，返回值表示的是需要merge进props的state。默认值为<code>() =&gt; ({})</code>，即什么都不传。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(state, props) =&gt; (&#123;  &#125;) <span class="comment">// 通常会省略第二个参数</span></div></pre></td></tr></table></figure></p>
<p><code>mapDispatchToProps</code>是可以是一个函数，返回值表示的是需要<code>merge</code>仅<code>props</code>的<code>actionCreators</code>，这里的<code>actionCreator</code>应该是已经被包装了<code>dispatch</code>了的，推荐使用<code>redux</code>的<code>bindActionCreators</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(dispatch, props) =&gt; (&#123; <span class="comment">// 通常会省略第二个参数</span></div><div class="line"> ...bindActionCreators(&#123;</div><div class="line">   ...ResourceActions</div><div class="line"> &#125;, dispatch)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>更方便的是可以直接接受一个对象，此时<code>connect</code>函数内部会将其转变为函数，这个函数和上面那个例子是一模一样的。</p>
<p><code>mergeProps</code>用于自定义<code>merge</code>流程，下面这个是默认流程，<code>parentProps</code>值的就是组件自身的<code>props</code>，可以发现如果组件的<code>props</code>上出现同名，会被覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(stateProps, dispatchProps, parentProps) =&gt; (&#123;</div><div class="line">  ...parentProps,</div><div class="line">  ...stateProps,</div><div class="line">  ...dispatchProps</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>options</code>共有两个开关：<code>pure</code>代表是否打开优化，详细内容下面会提，默认为<code>true</code>，<code>withRef</code>用来给包装在里面的组件一个<code>ref</code>，可以通过<code>getWrappedInstance</code>方法来获取这个<code>ref</code>，默认为<code>false</code>。</p>
<p><code>connect</code>返回一个函数，它接受一个<code>React</code>组件的构造函数作为连接对象，最终返回连接好的组件构造函数。</p>
<p>然后几个问题：</p>
<ul>
<li>React组件如何响应store的变化？</li>
<li>为什么connect选择性的merge一些props，而不是直接将整个state传入？</li>
<li>pure优化的是什么？</li>
</ul>
<p>我们把<code>connect</code>返回的函数叫做<code>Connector</code>，它返回的是内部的一个叫<code>Connect</code>的组件，它在包装原有组件的基础上，还在内部监听了<code>Redux</code>的<code>store</code>的变化，为了让被它包装的组件可以响应<code>store</code>的变化:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">trySubscribe() &#123;  </div><div class="line">  <span class="keyword">if</span> (shouldSubscribe &amp;&amp; !<span class="keyword">this</span>.unsubscribe) &#123;</div><div class="line">    <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(::<span class="keyword">this</span>.handleChange)</div><div class="line">    <span class="keyword">this</span>.handleChange()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">handleChange () &#123;  </div><div class="line">  <span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">storeState</span>: <span class="keyword">this</span>.store.getState()</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是通常，我们<code>connect</code>的是某个<code>Container</code>组件，它并不承载所有<code>App state</code>，然而我们的<code>handler</code>是响应所有<code>state</code>变化的，于是我们需要优化的是：当<code>storeState</code>变化的时候，仅在我们真正依赖那部分<code>state</code>变化时，才重新<code>render</code>相应的<code>React</code>组件，那么什么是我们真正依赖的部分？就是通过<code>mapStateToProps</code>和<code>mapDispatchToProps</code>得到的。</p>
<p>具体优化的方式就是在<code>shouldComponentUpdate</code>中做检查，如果只有在组件自身的<code>props</code>改变，或者<code>mapStateToProps</code>的结果改变，或者是<code>mapDispatchToProps</code>的结果改变时<code>shouldComponentUpdate</code>才会返回<code>true</code>，检查的方式是进行<code>shallowEqual</code>的比较。</p>
<p>所以对于某个reducer来说：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = &#123;&#125;, action) =&gt; &#123;  </div><div class="line">  <span class="keyword">return</span> &#123; ...state &#125; <span class="comment">// 返回的是一个新的对象，可能会使组件reRender</span></div><div class="line">  <span class="comment">// return state // 可能不会使得组件reRender</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外在<code>connect</code>的时候，要谨慎<code>map</code>真正需要的<code>state</code>或者<code>actionCreators</code>到<code>props</code>中，以避免不必要的性能损失。</p>
<p>最后，根据<code>connect</code>的<code>API</code>我们发现可以使用<code>ES7 decorator</code>功能来配合<code>React ES6</code>的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@connect(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">user</span>: state.user,</div><div class="line">    <span class="attr">resource</span>: state.resource</div><div class="line">  &#125;),</div><div class="line">  dispatch =&gt; (&#123;</div><div class="line">    ...bindActionCreators(&#123;</div><div class="line">      <span class="attr">loadResource</span>: ResourceActions.load</div><div class="line">    &#125;, dispatch)</div><div class="line">  &#125;)</div><div class="line">)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，结束了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://leozdgao.me/re
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
      <category term="redux" scheme="http://html-js.site/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>react事件研究及阻止冒泡</title>
    <link href="http://html-js.site/2017/08/25/react%E4%BA%8B%E4%BB%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1/"/>
    <id>http://html-js.site/2017/08/25/react事件研究及阻止冒泡/</id>
    <published>2017-08-25T14:14:08.000Z</published>
    <updated>2017-08-25T14:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React-中的事件处理逻辑"><a href="#React-中的事件处理逻辑" class="headerlink" title="React 中的事件处理逻辑"></a>React 中的事件处理逻辑</h3><p>为了解决跨浏览器兼容性问题，<code>React</code> 会将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的。</p>
<h3 id="合成事件-SyntheticEvent"><a href="#合成事件-SyntheticEvent" class="headerlink" title="合成事件 SyntheticEvent"></a>合成事件 SyntheticEvent</h3><p><code>SyntheticEvent</code> 是浏览器原生事件跨浏览器的封装。<code>SyntheticEvent</code> 和浏览器原生事件一样有 <code>stopPropagation()</code>、<code>preventDefault()</code> 接口，而且这些接口夸浏览器兼容。</p>
<p>如果出于某些原因想使用浏览器原生事件，可以使用 <code>nativeEvent</code> 属性获取。每个和成事件（<code>SyntheticEvent</code>）对象都有以下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">boolean bubbles</div><div class="line">boolean cancelable</div><div class="line">DOMEventTarget currentTarget</div><div class="line">boolean defaultPrevented</div><div class="line">Number eventPhase</div><div class="line">boolean isTrusted</div><div class="line">DOMEvent nativeEvent</div><div class="line">void preventDefault()</div><div class="line">void stopPropagation()</div><div class="line">DOMEventTarget target</div><div class="line">Date timeStamp</div><div class="line">String type</div></pre></td></tr></table></figure></p>
<h3 id="支持的事件"><a href="#支持的事件" class="headerlink" title="支持的事件"></a>支持的事件</h3><p>React 将事件统一化，使事件在不同浏览器上有一致的属性。</p>
<p>事件处理程序在事件冒泡阶段被触发。如果要注册事件捕获处理程序，应该使用 <code>Capture</code> 事件，例如使用 <code>onClickCapture</code> 处理点击事件的捕获阶段，而不是 <code>onClick</code>。</p>
<h3 id="阻止冒泡事件分三种情况"><a href="#阻止冒泡事件分三种情况" class="headerlink" title="阻止冒泡事件分三种情况"></a>阻止冒泡事件分三种情况</h3><p>A、阻止合成事件间的冒泡，用e.stopPropagation();<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM,&#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e)&#123;</div><div class="line">        <span class="comment">// 阻止合成事件间的冒泡</span></div><div class="line">        e.stopPropagation();</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    testClick()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'test'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div ref="test" onClick=&#123;()=&gt;this.testClick()&#125;&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</div><div class="line">                &lt;a ref="update" onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;更新&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line">ReactDOM.render(&lt;Counter/&gt;,div1,()=&gt;&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>B、阻止合成事件与最外层<code>document</code>上的事件间的冒泡，用<code>e.nativeEvent.stopImmediatePropagation()</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM,&#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e)&#123;</div><div class="line">        <span class="comment">// 阻止合成事件与最外层document上的事件间的冒泡</span></div><div class="line">        e.nativeEvent.stopImmediatePropagation();</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div ref="test"&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</div><div class="line">                &lt;a ref="update" onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;更新&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'document'</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line"></div><div class="line">ReactDOM.render(&lt;Counter/&gt;,div1,()=&gt;&#123;&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e-target来避免"><a href="#C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e-target来避免" class="headerlink" title="C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免"></a>C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM,&#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e)&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div ref="test"&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</div><div class="line">                &lt;a ref="update" onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;更新&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,e=&gt;&#123;</div><div class="line">            <span class="comment">// 通过e.target判断阻止冒泡</span></div><div class="line">            <span class="keyword">if</span>(e.target&amp;&amp;e.target.matches(<span class="string">'a'</span>))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'body'</span>);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line"></div><div class="line">ReactDOM.render(&lt;Counter/&gt;,div1,()=&gt;&#123;&#125;);</div></pre></td></tr></table></figure>
<h3 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h3><p><a href="https://stackoverflow.com/questions/24415631/reactjs-syntheticevent-stoppropagation-only-works-with-react-events" target="_blank" rel="external">https://stackoverflow.com/questions/24415631/reactjs-syntheticevent-stoppropagation-only-works-with-react-events</a></p>
<p>React uses event delegation with a single event listener on document for events that bubble, like ‘click’ in this example, which means stopping propagation is not possible; the real event has already propagated by the time you interact with it in React. stopPropagation on React’s synthetic event is possible because React handles propagation of synthetic events internally.</p>
<p>Working JSFiddle with the fixes from below: <a href="http://jsfiddle.net/7LEDT/6/" target="_blank" rel="external">http://jsfiddle.net/7LEDT/6/</a></p>
<p>React Stop Propagation on jQuery Event</p>
<p>Use <code>Event.stopImmediatePropagation</code> to prevent your other (jQuery in this case) listeners on the root from being called. It is supported in IE9+ and modern browsers.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line">    e.nativeEvent.stopImmediatePropagation();</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<ul>
<li>Caveat: Listeners are called in the order in which they are bound. React must be initialized before other code (jQuery here) for this to work.</li>
</ul>
<p>jQuery Stop Propagation on React Event</p>
<p>Your jQuery code uses event delegation as well, which means calling stopPropagation in the handler is not stopping anything; the event has already propagated to document, and React’s listener will be triggered.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Listener bound to `document`, event delegation</span></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'.stop-propagation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>To prevent propagation beyond the element, the listener must be bound to the element itself:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Listener bound to `.stop-propagation`, no delegation</span></div><div class="line">$(<span class="string">'.stop-propagation'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Clarified that delegation is necessarily only used for events that bubble. For more details on event handling, React’s source has descriptive comments: <a href="https://github.com/facebook/react/blob/3b96650e39ddda5ba49245713ef16dbc52d25e9e/src/renderers/dom/client/ReactBrowserEventEmitter.js#L23" target="_blank" rel="external">https://github.com/facebook/react/blob/3b96650e39ddda5ba49245713ef16dbc52d25e9e/src/renderers/dom/client/ReactBrowserEventEmitter.js#L23</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;React-中的事件处理逻辑&quot;&gt;&lt;a href=&quot;#React-中的事件处理逻辑&quot; class=&quot;headerlink&quot; title=&quot;React 中的事件处理逻辑&quot;&gt;&lt;/a&gt;React 中的事件处理逻辑&lt;/h3&gt;&lt;p&gt;为了解决跨浏览器兼容性问题，&lt;code&gt;Re
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的匿名递归</title>
    <link href="http://html-js.site/2017/08/17/JavaScript-%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E9%80%92%E5%BD%92/"/>
    <id>http://html-js.site/2017/08/17/JavaScript-中的匿名递归/</id>
    <published>2017-08-17T06:12:47.000Z</published>
    <updated>2017-08-17T08:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>代码如果这么写，过一段时间之后自己还能明白？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span> f(f)</div><div class="line">  )</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span></div><div class="line">      (l) =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line"><span class="keyword">if</span> (l.length) f(f)(l.slice(<span class="number">1</span>))</div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line">      &#125;</div><div class="line">  )</div><div class="line">)</div><div class="line">(</div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">)</div></pre></td></tr></table></figure>
<p>是的，这就是想要分享给大家的一个有趣的示例。这个例子包含以下特性：闭包)，自执行函数，箭头函数，函数式编程 和 匿名递归。</p>
<p>你可以复制粘贴上述代码到浏览器控制台，会看到打印结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">3</span> ]</div><div class="line">[]</div><div class="line">[]</div><div class="line">[ <span class="number">3</span> ]</div><div class="line">[ <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Unwind"><a href="#Unwind" class="headerlink" title="Unwind"></a>Unwind</h3><p>像其他很多编程语言一样，js函数调用是通过在函数名称后添加括号 () 来完成的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hey'</span> &#125;</div><div class="line">foo()</div></pre></td></tr></table></figure></p>
<p>在 JavaScript 中我们可以使用括号包裹任意数量的表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="string">'hey'</span>, <span class="number">2</span>+<span class="number">5</span>, <span class="string">'dev.to'</span>)</div></pre></td></tr></table></figure></p>
<p>上面代码返回结果是 ‘dev.to’，原因是 JavaScript 返回最后一个表达式作为结果。</p>
<p>使用括号 () 包裹一个匿名函数表示其结果就是 匿名函数 本身.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hey'</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>这本身并没有用处，因为匿名函数没有命名，无法被引用，除非在初始化的时候立即调用它。</p>
<p>就像是普通函数一样，我们可以在其后面添加括号 () 来进行调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hey'</span> &#125;)()</div></pre></td></tr></table></figure></p>
<p>也可以使用箭头函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'hey'</span>)()</div></pre></td></tr></table></figure></p>
<p>同样地，在匿名函数后添加括号 () 来执行函数，这被称为 自执行函数。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包) 指的是函数和该函数声明词法环境的组合。结合 箭头功能，我们可以定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">hi</span>) =&gt;</span> (dev) =&gt; hi + <span class="string">' '</span> + dev</div></pre></td></tr></table></figure></p>
<p>在控制台调用上述函数会打印 hey dev.to:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(<span class="string">'hey'</span>)(<span class="string">'dev.to'</span>)</div></pre></td></tr></table></figure></p>
<p>注意，我们可以在内部函数作用域访问外部函数的参数 hi。</p>
<p>以下代码跟上述代码一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">hi</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dev</span>) </span>&#123; <span class="keyword">return</span> hi + <span class="string">' '</span> + dev &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自执行的版本如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  <span class="function">(<span class="params">hi</span>) =&gt;</span></div><div class="line">    (</div><div class="line">      <span class="function">(<span class="params">dev</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;hi&#125;</span> <span class="subst">$&#123;dev&#125;</span>`</span></div><div class="line">    )</div><div class="line">    (<span class="string">'dev.to'</span>)</div><div class="line">)</div><div class="line">(<span class="string">'hey'</span>)</div></pre></td></tr></table></figure></p>
<p>首先，将 hey 作为参数 hi 的值传给最外层作用域的函数，然后这个函数返回另一个自执行函数。dev.to 作为参数 dev 的值传给内部函数，最后这个函数返回最终值：’hey dev.to’。</p>
<h3 id="再深入一点"><a href="#再深入一点" class="headerlink" title="再深入一点"></a>再深入一点</h3><p>这个一个上述自执行函数的修改版本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">dev</span>) =&gt;</span></div><div class="line">      (hi) =&gt; <span class="string">`<span class="subst">$&#123;hi&#125;</span> <span class="subst">$&#123;dev&#125;</span>`</span></div><div class="line">  )</div><div class="line">  (<span class="string">'dev.to'</span>)</div><div class="line">)</div><div class="line">(<span class="string">'hey'</span>)</div></pre></td></tr></table></figure></p>
<p>需要注意的是，自执行函数 和 闭包) 用作初始化和封装状态，接下来我们来看另外一个例子。</p>
<h3 id="匿名递归"><a href="#匿名递归" class="headerlink" title="匿名递归"></a>匿名递归</h3><p>回到我们最初的例子，这次加点注释：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span> f(f) <span class="comment">// 3.</span></div><div class="line">  )</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span> <span class="comment">// 2.</span></div><div class="line">      (l) =&gt; &#123; <span class="comment">// 4.</span></div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line"><span class="keyword">if</span> (l.length) f(f)(l.slice(<span class="number">1</span>))</div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line">      &#125;</div><div class="line">  )</div><div class="line">)</div><div class="line">(</div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 1.</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    (</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> f(f)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    (</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">l</span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'1'</span>,l)</div><div class="line">                <span class="keyword">if</span>(l.length)</div><div class="line">                    f(f)(l.slice(<span class="number">1</span>))</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'2'</span>,l)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">)([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">l</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'1'</span>,l)</div><div class="line">        <span class="keyword">if</span>(l.length)</div><div class="line">            f(f)(l.slice(<span class="number">1</span>))</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'2'</span>,l)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">b(b)([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure></p>
<ul>
<li>输入函数 [1, 2, 3] 传给最外层作用域</li>
<li>整个函数作为参数传给上面函数</li>
<li>这个函数接收下面函数作为参数 f 的值，然后自身调用</li>
<li>2.将被调用被作为 3.的结果然后返回函数 4. ，该函数是满足最外层作用域的函数，因此接收输入数组作为 l 参数的值</li>
</ul>
<p>至于结果为什么是那样子，原因是在递归内部有一个对函数 f 的引用来接收输入数组 l。所以能那样调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(f)(l.slice(<span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<p>注意，f 是一个闭包，所以我们只需要调用它就可以访问到操作输入数组的最里面的函数。</p>
<p>为了说明目的，第一个 console.log(l) 语句表示递归自上而下，第二个语句表示递归自下而上。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>希望你喜欢这篇文章，并从中学到了新的东西。闭包、自执行函数、函数式编程模式不是黑魔法。它们遵循一套易于理解和玩乐的简单原则。</p>
<p>话虽如此，你必须培养自己何时使用它们，何时不用的这样一种感觉。如果你的代码变得难以维护，那这可能会成为重构中一些好点子。</p>
<p>然而，理解这些基本技术对于创建清晰优雅的解决方案以及提升自我是至关重要的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;代码如果这么写，过一段时间之后自己还能明白？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;f&lt;/span&gt;) =&amp;gt;&lt;/span&gt; f(f)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;f&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      (l) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l.length) f(f)(l.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;是的，这就是想要分享给大家的一个有趣的示例。这个例子包含以下特性：闭包)，自执行函数，箭头函数，函数式编程 和 匿名递归。&lt;/p&gt;
&lt;p&gt;你可以复制粘贴上述代码到浏览器控制台，会看到打印结果如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
      <category term="es6" scheme="http://html-js.site/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>八段代码彻底掌握 Promise</title>
    <link href="http://html-js.site/2017/08/01/%E5%85%AB%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Promise/"/>
    <id>http://html-js.site/2017/08/01/八段代码彻底掌握-Promise/</id>
    <published>2017-08-01T06:51:00.000Z</published>
    <updated>2017-08-01T12:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;create a promise&quot;</div><div class="line">&quot;after new Promise&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。<br><a id="more"></a></p>
<h3 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    reject(<span class="number">3</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1);</div><div class="line"><span class="built_in">console</span>.log(p2);</div><div class="line"><span class="built_in">console</span>.log(p3);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p2);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p3);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h3 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success1"</span>);</div><div class="line">  resolve(<span class="string">"success2"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">  reject(<span class="string">"reject"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;success1&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise状态的一旦变成<code>resolved</code>或<code>rejected</code>时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为success2，p2中r<code>eject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>
<h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">undefined</div><div class="line">&quot;resolve&quot;</div><div class="line">&quot;reject: reject&quot;</div></pre></td></tr></table></figure></p>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><code>return</code> 一个同步的值 ，或者 <code>undefined</code>（当没有返回一个有效值时，默认返回undefined），<code>then</code>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><code>return</code> 另一个 Promise，<code>then</code>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
<li><code>throw</code> 一个同步异常，<code>then</code>方法将返回一个rejected状态的Promise, 值是该异常。</li>
</ul>
<h3 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;which one is called first ?&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise接收的函数参数是同步执行的，但<code>then</code>方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h3 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  foo.bar();</div><div class="line">  resolve( <span class="number">1</span> );      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve( <span class="number">2</span> );    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</div><div class="line">    foo.bar();</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p1 then err: ReferenceError: foo is not defined</div><div class="line">p2 then value: 2</div><div class="line">p1 then then value: undefined</div><div class="line">p2 then then err: ReferenceError: foo is not defined</div><div class="line">p2 then then then value: 1</div></pre></td></tr></table></figure></p>
<p>Promise中的异常由<code>then</code>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<code>then</code>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<code>then</code>的回调函数是交替执行的 ，这正是由Promise <code>then</code>回调的异步性决定的。</p>
<h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</div><div class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1 === p2); </div><div class="line"><span class="built_in">console</span>.log(p1 === p3);</div><div class="line"><span class="built_in">console</span>.log(p1 === p4);</div><div class="line"><span class="built_in">console</span>.log(p3 === p4);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line">false</div><div class="line">p2=1</div><div class="line">p1=1</div><div class="line">p4=1</div></pre></td></tr></table></figure></p>
<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<code>then</code>最先调用，但在控制台上是最后输出结果的呢？因为p4的<code>resolve</code>中接收的参数是一个Promise对象p1，<code>resolve</code>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h3 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p3.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p3 rejected: [object Promise]</div><div class="line">p1 fulfilled: resolve</div><div class="line">p2 rejected: reject</div></pre></td></tr></table></figure></p>
<p>Promise回调函数中的第一个参数<code>resolve</code>，会对Promise执行”拆箱”动作。即当<code>resolve</code>的参数是一个Promise对象时，<code>resolve</code>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是<code>resolved</code>，因此<code>fulfilled</code>回调被执行；p2”拆箱”后，获取到Promise对象的状态是<code>rejected</code>，因此<code>rejected</code>回调被执行。但Promise回调函数中的第二个参数<code>reject</code>不具备”拆箱“的能力，<code>reject</code>的参数会直接传递给then方法中的<code>rejected</code>回调。因此，即使p3 reject接收了一个<code>resolved</code>状态的Promise，<code>then</code>方法中被调用的依然是<code>rejected</code>，并且参数就是<code>reject</code>接收到的Promise对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Promise的立即执行性&quot;&gt;&lt;a href=&quot;#1-Promise的立即执行性&quot; class=&quot;headerlink&quot; title=&quot;1.Promise的立即执行性&quot;&gt;&lt;/a&gt;1.Promise的立即执行性&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;create a promise&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  resolve(&lt;span class=&quot;string&quot;&gt;&quot;success&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;after new Promise&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;p.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;控制台输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;create a promise&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;after new Promise&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;success&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="ECMAScript6" scheme="http://html-js.site/tags/ECMAScript6/"/>
    
      <category term="promise" scheme="http://html-js.site/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>webpack的重要功能——Plugins</title>
    <link href="http://html-js.site/2017/06/23/webpack%E7%9A%84%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94Plugins/"/>
    <id>http://html-js.site/2017/06/23/webpack的重要功能——Plugins/</id>
    <published>2017-06-23T06:57:18.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>webpack</code>中另一个非常重要的功能是<code>Plugins</code>。<br>插件（<code>Plugins</code>）是用来拓展<code>webpack</code>功能的，它们会在整个构建过程中生效，执行相关的任务。<br><code>Loaders</code>和<code>Plugins</code>常常被弄混，但是他们其实是完全不同的东西：<code>Loaders</code>是在打包构建过程中用来处理源文件的（<code>JSX，Scss，Less..</code>），一次处理一个;插件并不直接操作单个文件，它直接对整个构建过程其作用。<br><code>webpack</code>有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<a id="more"></a>
<h2 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h2><p>要使用某个插件，需要通过<code>npm</code>安装它，然后在<code>webpack.config.js</code>中的<code>plugins</code>关键字部分添加该插件的一个实例（<code>plugins</code>是一个数组，<code>new</code>一个插件即可）。<br>如添加一个实现版权声明的插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>:  __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;...&#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;<span class="comment">//这里添加PostCSS  </span></div><div class="line">                ]  </div><div class="line">    &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">        <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Copyright Flying Unicorns inc."</span>)    </div><div class="line">    ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;...&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="几个常用的插件"><a href="#几个常用的插件" class="headerlink" title="几个常用的插件"></a>几个常用的插件</h2><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>这个插件的作用是依据一个简单的模板，帮助生成最终的<code>HTML5</code>文件，这个文件中自动引用了打包后的<code>JS</code>文件。每次编译都在文件名中插入一个不同的哈希值。<br>安装命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev html-webpack-plugin</div></pre></td></tr></table></figure></p>
<p>这个插件自动完成了之前手动做的一些事情，在正式使用之前需要对项目结构做一些改变：</p>
<ol>
<li>移除public文件夹，利用此插件，html5文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。</li>
<li><p>在app目录下，创建一个HTML文件模板index.tmpl.html，这个模板包含title等其它需要的元素，在编译过程中，本插件会依据此模板生成最终的HTML页面，会自动添加所依赖的 css, js，favicon等文件，模板源代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;  </div><div class="line">&lt;html lang="en"&gt;  </div><div class="line">    &lt;head&gt;  </div><div class="line">    &lt;/head&gt;  </div><div class="line">    &lt;body&gt;  </div><div class="line">            &lt;div id='root'&gt;  </div><div class="line">            &lt;/div&gt;  </div><div class="line">    &lt;/body&gt;  </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>更新webpack的配置文件，方法同上，新建一个build文件夹用来存放最终的输出文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);<span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </div><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>:  __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;  </div><div class="line">                <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,  </div><div class="line">                <span class="attr">filename</span>: <span class="string">"bundle.js"</span>  </div><div class="line">        &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;  </div><div class="line">            ]  </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">        <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  </div><div class="line">                    <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span><span class="comment">//new 一个这个插件的实例，并传入相关的参数  </span></div><div class="line">                &#125;)  </div><div class="line">        ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">                <span class="attr">colors</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">inline</span>: <span class="literal">true</span>  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h3><p><code>Hot Module Replacement（HMR）</code>也是<code>webpack</code>里很有用的一个插件，它允许在修改组件代码后，自动刷新实时预览修改后的效果。<br>在<code>webpack</code>中实现<code>HMR</code>也很简单，只需要做两项配置</p>
<ol>
<li>在webpack配置文件中添加HMR插件；</li>
<li>在Webpack Dev Server中添加“hot”参数。</li>
</ol>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个<code>Webpack</code>提供的<code>API</code>才能实现热加载，虽然这个<code>API</code>不难使用，但是如果是<code>React</code>模块，使用已经熟悉的<code>Babel</code>可以更方便的实现功能热加载。<br>具体实现方法如下：</p>
<ol>
<li>Babel和webpack是独立的工具；</li>
<li>二者可以一起工作；</li>
<li>二者都可以通过插件拓展功能；</li>
<li>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；</li>
<li>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);  </div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </div><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;  </div><div class="line">                <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,  </div><div class="line">                <span class="attr">filename</span>: <span class="string">"bundle.js"</span>  </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;  </div><div class="line">                ]     </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">    <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  </div><div class="line">                    <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span>  </div><div class="line">                &#125;),  </div><div class="line">                <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()<span class="comment">//热加载插件  </span></div><div class="line">        ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">                <span class="attr">colors</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">inline</span>: <span class="literal">true</span>,  </div><div class="line">            <span class="attr">hot</span>: <span class="literal">true</span>  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>安装react-transform-hmr：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-plugin-react-transform react-transform-hmr</div></pre></td></tr></table></figure></p>
<p>配置Babel<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">        <span class="string">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>],  </div><div class="line">        <span class="string">"env"</span>: &#123;  </div><div class="line">                <span class="string">"development"</span>: &#123;  </div><div class="line">                    <span class="string">"plugins"</span>: [[<span class="string">"react-transform"</span>, &#123;  </div><div class="line">                    <span class="string">"transforms"</span>: [&#123;  </div><div class="line">                            <span class="string">"transform"</span>: <span class="string">"react-transform-hmr"</span>,  </div><div class="line">                    <span class="string">"imports"</span>: [<span class="string">"react"</span>],  </div><div class="line">                    <span class="string">"locals"</span>: [<span class="string">"module"</span>]  </div><div class="line">                    &#125;]  </div><div class="line">                    &#125;]]  </div><div class="line">        &#125;  </div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用React时，可以热加载模块了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;中另一个非常重要的功能是&lt;code&gt;Plugins&lt;/code&gt;。&lt;br&gt;插件（&lt;code&gt;Plugins&lt;/code&gt;）是用来拓展&lt;code&gt;webpack&lt;/code&gt;功能的，它们会在整个构建过程中生效，执行相关的任务。&lt;br&gt;&lt;code&gt;Loaders&lt;/code&gt;和&lt;code&gt;Plugins&lt;/code&gt;常常被弄混，但是他们其实是完全不同的东西：&lt;code&gt;Loaders&lt;/code&gt;是在打包构建过程中用来处理源文件的（&lt;code&gt;JSX，Scss，Less..&lt;/code&gt;），一次处理一个;插件并不直接操作单个文件，它直接对整个构建过程其作用。&lt;br&gt;&lt;code&gt;webpack&lt;/code&gt;有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack最强大的功能———Loaders</title>
    <link href="http://html-js.site/2017/06/23/webpack%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94%E2%80%94Loaders/"/>
    <id>http://html-js.site/2017/06/23/webpack最强大的功能———Loaders/</id>
    <published>2017-06-23T02:06:43.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p><code>Loaders</code>是<code>webpack</code>中最强大的功能之一了。通过使用不同的<code>loader</code>，<code>webpack</code>通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，如分析<code>JSON</code>文件并把它转换为<code>JavaScript</code>文件；或把下一代的<code>js</code>文件（<code>ES6，ES7</code>)转换为现代浏览器可以识别的<code>JS</code>文件；或对<code>React</code>的开发而言，合适的<code>Loaders</code>可以把<code>react</code>的<code>JSX</code>文件转换为<code>JS</code>文件。</p>
<p><code>Loaders</code>需要单独安装并且需要在<code>webpack.config.js</code>下的<code>modules</code>关键字下进行配置。安装命令为<code>npm install --save-dev json-loader</code>，<code>Loaders</code>的配置选项包括以下几方面：</p>
<ul>
<li>test  一个匹配loaders所处理的文件的拓展名的正则表达式（必须）</li>
<li>loader  loader的名称（必须）</li>
<li>include/exclude  手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</li>
<li>query  为loaders提供额外的设置选项（可选）<a id="more"></a>
</li>
</ul>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p><code>Loaders</code>很好，不过有的<code>Loaders</code>使用起来比较复杂，如<code>Babel</code>。<br><code>Babel</code>其实是一个编译<code>javascript</code>的平台，它的强大之处表现在可以通过编译达到以下目的：</p>
<ul>
<li>1) 下一代的<code>JavaScript</code>标准（<code>ES6，ES7</code>），这些标准目前并未被当前的浏览器完全的支持；</li>
<li>2) 使用基于<code>JavaScript</code>进行了拓展的语言，如<code>React</code>的<code>JSX</code>。<br><code>Babel</code>其实是几个模块化的包，其核心功能位于称为<code>babel-core</code>的<code>npm</code>包中，不过<code>webpack</code>把它们整合在一起使用，但是对于每一个需要的功能或拓展，都需要安装单独的包（用得最多的是解析Es6的<code>babel-preset-es2015</code>包和解析<code>JSX</code>的<code>babel-preset-react</code>包）。<br>一次性安装这些依赖包（npm一次性安装多个依赖模块，模块之间用空格隔开）：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>webpack</code>中配置<code>Babel</code>的方法如下（在<code>webpack.config.js</code>的<code>module</code>部分的<code>loaders</code>里进行配置即可）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>webpack</code>进行以上配置后，允许使用<code>ES6</code>以及<code>JSX</code>的语法。</p>
<p><strong>Babel的配置选项：</strong><br><code>Babel</code>其实可以完全在<code>webpack.config.js</code>中进行配置，但考虑到<code>babel</code>具有非常多的配置选项，在单一的<code>webpack.config.js</code>文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把<code>babel</code>的配置选项放在一个单独的名为 <code>&quot;.babelrc&quot;</code> 的配置文件中。现在的<code>babel</code>的配置并不算复杂，不过之后会再加一些东西，因此现在就提取出相关部分，分两个配置文件进行配置（<code>webpack</code>会自动调用<code>.babelrc</code>里的<code>babel</code>配置选项），如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>.babelrc：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">    <span class="string">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>]  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><code>webpack</code>的优点：把所有的文件都可以当做模块处理，包括<code>JavaScript</code>代码，也包括<code>CSS</code>和<code>fonts</code>以及图片等，通过合适的<code>loaders</code>，它们都可以被当做模块被处理。<br><strong>1）CSS</strong><br><code>webpack</code>提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code>，二者处理的任务不同，<code>css-loader</code>使得能够使用类似<code>@import</code> 和 <code>url(...)</code>的方法实现 <code>require()</code>的功能，<code>style-loader</code>将所有的计算后的样式加入页面中，二者组合在一起能够把样式表嵌入<code>webpack</code>打包后的JS文件中。<br>安装命令：<code>npm install --save-dev style-loader css-loader</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：感叹号的作用在于使同一文件能够使用不同类型的<code>loader</code>。</p>
<p><strong>2）CSS modules</strong><br><code>CSS modules</code> 的技术就意在把<code>JS</code>的模块化思想带入<code>CSS</code>中来，通过<code>CSS</code>模块，所有的类名，动画名默认都只作用于当前模块。<code>Webpack</code>从一开始就对<code>CSS</code>模块化提供了支持，在<code>CSS loader</code>中进行配置后，所需要做的一切就是把<code>modules</code>传递都所需要的地方，然后就可以直接把<code>CSS</code>的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。具体的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>有关<code>Less Loader</code>、<code>Sass Loader</code>、<code>Stylus Loader</code>的介绍请见：<a href="http://blog.csdn.net/zhouziyu2011/article/details/67646875。" target="_blank" rel="external">http://blog.csdn.net/zhouziyu2011/article/details/67646875。</a><br>还有一个<code>CSS</code>的处理平台-<code>PostCSS</code>，可以帮助<code>CSS</code>实现更多的功能，使用<code>PostCSS</code>来为<code>CSS</code>代码自动添加适应不同浏览器的CSS前缀。<br>安装<code>postcss-loader</code> 和 <code>autoprefixer</code>（自动添加前缀的插件）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev postcss-loader autoprefixer。</div></pre></td></tr></table></figure></p>
<p>在<code>webpack.config.js</code>中进行设置，只需要新建一个<code>postcss</code>关键字，并在里面申明依赖的插件，<code>css</code>会自动根据数据添加不同前缀了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">postcss</span>: [  </div><div class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)<span class="comment">//调用autoprefixer插件  </span></div><div class="line">    ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>处理<code>JS</code>的<code>Babel</code>和处理<code>CSS</code>的<code>PostCSS</code>其实也是两个单独的平台，配合<code>Webpack</code>可以很好的发挥它们的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Loaders&quot;&gt;&lt;a href=&quot;#Loaders&quot; class=&quot;headerlink&quot; title=&quot;Loaders&quot;&gt;&lt;/a&gt;Loaders&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Loaders&lt;/code&gt;是&lt;code&gt;webpack&lt;/code&gt;中最强大的功能之一了。通过使用不同的&lt;code&gt;loader&lt;/code&gt;，&lt;code&gt;webpack&lt;/code&gt;通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，如分析&lt;code&gt;JSON&lt;/code&gt;文件并把它转换为&lt;code&gt;JavaScript&lt;/code&gt;文件；或把下一代的&lt;code&gt;js&lt;/code&gt;文件（&lt;code&gt;ES6，ES7&lt;/code&gt;)转换为现代浏览器可以识别的&lt;code&gt;JS&lt;/code&gt;文件；或对&lt;code&gt;React&lt;/code&gt;的开发而言，合适的&lt;code&gt;Loaders&lt;/code&gt;可以把&lt;code&gt;react&lt;/code&gt;的&lt;code&gt;JSX&lt;/code&gt;文件转换为&lt;code&gt;JS&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Loaders&lt;/code&gt;需要单独安装并且需要在&lt;code&gt;webpack.config.js&lt;/code&gt;下的&lt;code&gt;modules&lt;/code&gt;关键字下进行配置。安装命令为&lt;code&gt;npm install --save-dev json-loader&lt;/code&gt;，&lt;code&gt;Loaders&lt;/code&gt;的配置选项包括以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test  一个匹配loaders所处理的文件的拓展名的正则表达式（必须）&lt;/li&gt;
&lt;li&gt;loader  loader的名称（必须）&lt;/li&gt;
&lt;li&gt;include/exclude  手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）&lt;/li&gt;
&lt;li&gt;query  为loaders提供额外的设置选项（可选）
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>浅谈webpack模块引用的五种方法</title>
    <link href="http://html-js.site/2017/06/23/%E6%B5%85%E8%B0%88webpack%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://html-js.site/2017/06/23/浅谈webpack模块引用的五种方法/</id>
    <published>2017-06-23T01:24:54.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="commonjs格式的require同步语法"><a href="#commonjs格式的require同步语法" class="headerlink" title="commonjs格式的require同步语法"></a>commonjs格式的require同步语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">… <span class="comment">// 使用</span></div></pre></td></tr></table></figure>
<h3 id="commonjs格式的require-ensure异步语法"><a href="#commonjs格式的require-ensure异步语法" class="headerlink" title="commonjs格式的require.ensure异步语法"></a>commonjs格式的require.ensure异步语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>Home.js会被打包成一个单独的chunk文件：1.fb874860b35831bc96a8.js，其名称不具有可读性，因此一般给require.ensure传递第三个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>Home.js会被打包成一个具有指定文件名称的chunk文件：home.fb874860b35831bc96a8.js，该文件在bundle目录下。<br>在webpack.config.js文件中配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output: &#123;  </div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">'/public'</span>,  </div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span>,  </div><div class="line">    <span class="attr">chunkFilename</span>: <span class="string">'[name].bundle.js'</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Home.js会被打包成一个具有指定文件名称的chunk文件：home.bundle.js，该文件在bundle目录下，而bundle目录又在/public目录下。<br>注意：如果在require.ensure的回调函数中引用了两个以上的模块，webpack会把它们打包在一起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">    <span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/a-b<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>a.js和b.js会被打包成一个具有指定文件名称的chunk文件：a-b.bundle.js，，该文件在bundle目录下。如果不希望打包在一起，只能写多个require.ensure分别引用每一个模块。<br>给require.ensure传递的第一个参数可以是空数组，其实也可以是模块，实现预加载懒执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([<span class="string">'./Home'</span>], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>Home.js会被下载下来，即所谓的预加载，但不会执行Home.js模块中的代码，当执行到onsthome = require(‘./Home’)一句时才执行，即所谓的懒执行。</p>
<h3 id="webpack自带的require-include"><a href="#webpack自带的require-include" class="headerlink" title="webpack自带的require.include"></a>webpack自带的require.include</h3><p>require.include是webpack自身提供的，它可以实现require.ensure中的预加载功能，而不用把模块写在数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="built_in">require</span>.include(<span class="string">'./Home'</span>);<span class="comment">// 只加载不执行  </span></div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>require.include的返回值是undefined，如果想使用模块，需要再通过require引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="built_in">require</span>.include(<span class="string">'./Home'</span>);<span class="comment">// 只加载不执行  </span></div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>); <span class="comment">// 执行  </span></div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<h3 id="AMD异步加载"><a href="#AMD异步加载" class="headerlink" title="AMD异步加载"></a>AMD异步加载</h3><p>webpack既支持commonjs规范也支持AMD规范。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./Home'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">home</span>)</span>&#123;  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果写了多个模块，那么这些模块都会被打包成一个文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>a.js和b.js会被打包在一起，但AMD的方式无法传入第三个参数来指定文件名称。<br>require AMD与require.ensure的区别：</p>
<ul>
<li>require AMD传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数；</li>
<li>require.ensure也是传递一个模块数组和回调函数，但是模块只会被下载下来，不会被执行，只有在回调函数中执行到require(模块)一句时，该模块才会被执行。<br>在webpack.config.js文件中配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">entry</span>: <span class="string">'index.js'</span>  </div><div class="line">    output: &#123;  </div><div class="line">            <span class="attr">path</span>: __dirname + <span class="string">'/public'</span>,  </div><div class="line">            <span class="attr">filename</span>: <span class="string">'[name].js'</span>,  </div><div class="line">            <span class="attr">chunkFilename</span>: <span class="string">'[name].bundle.js'</span>  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ES6的import"><a href="#ES6的import" class="headerlink" title="ES6的import"></a>ES6的import</h3><p>import会被转化为commonjs格式或是AMD格式，所以它不是一种新的模块引用方式。babel默认会把ES6的模块转化为commonjs规范，因此不需要再把它转成AMD规范。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'./Home'</span>;</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;commonjs格式的require同步语法&quot;&gt;&lt;a href=&quot;#commonjs格式的require同步语法&quot; class=&quot;headerlink&quot; title=&quot;commonjs格式的require同步语法&quot;&gt;&lt;/a&gt;commonjs格式的require同步语法&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; home = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./Home&#39;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;… &lt;span class=&quot;comment&quot;&gt;// 使用&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;commonjs格式的require-ensure异步语法&quot;&gt;&lt;a href=&quot;#commonjs格式的require-ensure异步语法&quot; class=&quot;headerlink&quot; title=&quot;commonjs格式的require.ensure异步语法&quot;&gt;&lt;/a&gt;commonjs格式的require.ensure异步语法&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt; =&amp;gt; &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; home = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./Home&#39;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    … &lt;span class=&quot;comment&quot;&gt;//使用  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门</title>
    <link href="http://html-js.site/2017/06/22/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://html-js.site/2017/06/22/webpack入门/</id>
    <published>2017-06-22T11:13:44.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在webpack看来，所有的资源文件都是模块，只是处理的方式不同。<br>webpack解决的需求点是：如何更好地加载前端模块。</p>
<h3 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h3><p>只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果webpack没有进行全局安装，那么在终端中使用此命令时，需要额外指定其在node_modules中的地址。</p>
<p>若webpack全局安装，使用webpack app/main.js public/bundle.js命令即可。<br>若webpack非全局安装，需使用node_modules.bin\webpack app/main.js public/bundle.js命令。<br>注意：node_modules.bin\webpack的路径需用右斜杠形式，用左斜杠形式会报错。<br><a id="more"></a></p>
<h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>webpack拥有很多其它比较高级的功能，如<code>loaders</code>和<code>plugins</code>，这些功能其实都可以通过命令行模式实现，但这样不太方便且容易出错，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的<code>javascript</code>模块，可以把所有的与构建相关的信息放在里面。<br>以上面例子为例，在当根目录下新建一个名为<code>webpack.config.js</code>的文件，并进行配置，它包含入口文件路径和存放打包后文件的地方的路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;    </div><div class="line">    <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 唯一入口文件    </span></div><div class="line">    output: &#123;      </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方      </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<code>__dirname</code>是<code>node.js</code>中的一个全局变量，它指向当前执行脚本所在的目录。<br>若<code>webpack</code>全局安装，使用<code>webpack</code>命令即可。<br>若<code>webpack</code>非全局安装，需使用<code>node_modules\.bin\webpack</code>命令。<br>这条命令会自动参考<code>webpack.config.js</code>文件中的配置选项打包项目，按照上面提到的结果查看方法即可查看结果。</p>
<h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>执行类似于<code>node_modules\.bin\webpack</code>这样的命令其实是容易出错的，<code>npm</code>可以引导任务执行，对其进行配置后可以使用简单的<code>npm start</code>命令来代替这些繁琐的命令。在<code>package.json</code>中对<code>npm</code>的脚本部分进行相关设置即可：<br>默认的<code>test</code>直接删除，设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;  </div><div class="line">    <span class="string">"start"</span>: <span class="string">"webpack"</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：添加注释<code>//</code>或者<code>/**/</code>在<code>JSON</code>文件中是不允许的，若用<code>js</code>的方式添加注释会报错。<br><code>package.json</code>中的脚本部分已经默认在命令前添加了<code>node_modules\.bin</code>路径，所以无论是全局还是局部安装的<code>webpack</code>，都不需要在前面指明详细的路径了。<br>无论是全局安装还是非全局安装，都只需要使用<code>npm start</code>命令，按照上面提到的结果查看方法即可查看结果。</p>
<h3 id="生成Source-Maps（调试更容易）"><a href="#生成Source-Maps（调试更容易）" class="headerlink" title="生成Source Maps（调试更容易）"></a>生成Source Maps（调试更容易）</h3><p>打包后的文件往往不容易找到出错的源代码的位置，<code>Source Maps</code>可以解决这个问题。<br>通过简单的配置后，<code>webpack</code>在打包时可以生成<code>source maps</code>，提供一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。<br>在<code>webpack</code>的配置文件中配置<code>source maps</code>，需要配置<code>devtool</code>，它有以下四种不同的配置选项，各具优缺点，描述如下：<br><code>devtool</code>选项  配置结果 </p>
<ul>
<li>source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的<code>source map</code>，但是它会减慢打包文件的构建速度。</li>
<li>cheap-module-source-map 在一个单独的文件中生成一个不带列映射的<code>map</code>，不带列映射提高项目构建速度，但也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</li>
<li>eval-source-map 使用<code>eval</code>打包源文件模块，在同一个文件中生成干净的完整的<code>source map</code>。这个选项可以在不影响构建速度的前提下生成完整的<code>sourcemap</code>，但是对打包后输出的<code>JS</code>文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项。</li>
<li>cheap-module-eval-source-map 这是在打包文件时最快的生成<code>source map</code>的方法，生成的<code>Source map</code>会和打包后的<code>JS</code>文件同行显示，没有列映射，和<code>eval-source-map</code>选项具有相似的缺点。</li>
</ul>
<p>上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。<br>在学习阶段以及在小到中性的项目上，<code>eval-source-map</code>是一个很好的选项，不过记得只在开发阶段使用它；<code>cheap-module-eval-source-map</code>方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。</p>
<p>以上述例子为例，继续配置webpack.config.js文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, <span class="comment">// 配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>, <span class="comment">// 打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span> <span class="comment">// 打包后输出文件的文件名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><p><code>webpack</code>提供一个可选的本地开发服务器，这个本地服务器基于<code>node.js</code>构建，可以实现浏览器监测代码的修改，并自动刷新修改后的结果，不过它是一个单独的组件，在<code>webpack</code>中进行配置之前需要单独安装它作为项目依赖，安装命令为<code>npm install --save-dev webpack-dev-server</code>。<br><code>devserver</code>作为<code>webpack</code>配置选项中的一项，具有以下配置选项：</p>
<ul>
<li>contentBase 默认<code>webpack-dev-server</code>会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录</li>
<li>port 设置默认监听端口，如果省略，默认为<code>8080</code></li>
<li>inline 设置为<code>true</code>，当源文件改变时会自动刷新页面</li>
<li>colors 设置为<code>true</code>，使终端输出的文件为彩色的</li>
<li>historyApiFallback 在开发单页应用时非常有用，它依赖于<code>HTML5 history API</code>，如果设置为<code>true</code>，所有的跳转将指向<code>index.html</code></li>
</ul>
<p>以上述例子为例，继续配置<code>webpack.config.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, <span class="comment">// 配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>, <span class="comment">// 打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span> <span class="comment">// 打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>webpack有两个重要的功能：Loaders和Plugins。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在webpack看来，所有的资源文件都是模块，只是处理的方式不同。&lt;br&gt;webpack解决的需求点是：如何更好地加载前端模块。&lt;/p&gt;
&lt;h3 id=&quot;使用webpack&quot;&gt;&lt;a href=&quot;#使用webpack&quot; class=&quot;headerlink&quot; title=&quot;使用webpack&quot;&gt;&lt;/a&gt;使用webpack&lt;/h3&gt;&lt;p&gt;只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果webpack没有进行全局安装，那么在终端中使用此命令时，需要额外指定其在node_modules中的地址。&lt;/p&gt;
&lt;p&gt;若webpack全局安装，使用webpack app/main.js public/bundle.js命令即可。&lt;br&gt;若webpack非全局安装，需使用node_modules.bin\webpack app/main.js public/bundle.js命令。&lt;br&gt;注意：node_modules.bin\webpack的路径需用右斜杠形式，用左斜杠形式会报错。&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>npmlist</title>
    <link href="http://html-js.site/2017/06/07/npmlist/"/>
    <id>http://html-js.site/2017/06/07/npmlist/</id>
    <published>2017-06-07T02:48:19.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里收集了一些目前用到的一些npm库以及相关的功能</p>
<h3 id="node-glob-获取对应规则的文件-路径-所有文件"><a href="#node-glob-获取对应规则的文件-路径-所有文件" class="headerlink" title="node-glob  获取对应规则的文件/路径/所有文件"></a>node-glob  获取对应规则的文件/路径/所有文件</h3><blockquote>
<p>node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.<br>这个glob工具基于javascript.它使用了 minimatch 库来进行匹配<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a><br><a id="more"></a></p>
</blockquote>
<h3 id="inquirer-js-常见的交互式命令行用户接口的集合"><a href="#inquirer-js-常见的交互式命令行用户接口的集合" class="headerlink" title="inquirer.js 常见的交互式命令行用户接口的集合"></a>inquirer.js 常见的交互式命令行用户接口的集合</h3><p>创建交互式命令行用户接口<br><img src="/images/page/inquirer/1.png" alt=""></p>
<p>github地址： <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="external">https://github.com/SBoudrias/Inquirer.js</a></p>
<h3 id="commander-js-node-js命令行接口的完整解决方案"><a href="#commander-js-node-js命令行接口的完整解决方案" class="headerlink" title="commander.js node.js命令行接口的完整解决方案"></a>commander.js node.js命令行接口的完整解决方案</h3><p><a href="http://nodejs.org" target="_blank" rel="external">node.js</a> 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。<br><a href="http://tj.github.com/commander.js/" target="_blank" rel="external">API 文档</a><br>本文所有的例子都可以用 <code>node name.js &lt;command/option&gt;</code> 执行<br>吐槽：commander.js中文文档真的好难找哇</p>
<h3 id="portscanner-端口检查器"><a href="#portscanner-端口检查器" class="headerlink" title="portscanner 端口检查器"></a>portscanner 端口检查器</h3><p>portscanner可以检查对应端口是否被占用<br><a href="https://github.com/baalexander/node-portscanner" target="_blank" rel="external">https://github.com/baalexander/node-portscanner</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收集了一些目前用到的一些npm库以及相关的功能&lt;/p&gt;
&lt;h3 id=&quot;node-glob-获取对应规则的文件-路径-所有文件&quot;&gt;&lt;a href=&quot;#node-glob-获取对应规则的文件-路径-所有文件&quot; class=&quot;headerlink&quot; title=&quot;node-glob  获取对应规则的文件/路径/所有文件&quot;&gt;&lt;/a&gt;node-glob  获取对应规则的文件/路径/所有文件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.&lt;br&gt;这个glob工具基于javascript.它使用了 minimatch 库来进行匹配&lt;br&gt;&lt;a href=&quot;https://github.com/isaacs/node-glob&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node-glob</title>
    <link href="http://html-js.site/2017/06/02/node-glob/"/>
    <id>http://html-js.site/2017/06/02/node-glob/</id>
    <published>2017-06-02T09:38:16.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.<br>这个glob工具基于javascript.它使用了 minimatch 库来进行匹配<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a></p>
</blockquote>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install glob</div></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)</div><div class="line"></div><div class="line"><span class="comment">// options 是可选的</span></div><div class="line">glob(<span class="string">"**/*.js"</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">  <span class="comment">// files 是匹配到的文件的数组.</span></div><div class="line">  <span class="comment">// 如果 `nonull` 选项被设置为true, 而且没有找到任何文件,那么files就是glob规则本身,而不是空数组</span></div><div class="line">  <span class="comment">// er是当寻找的过程中遇的错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>“globs” 就是模型,比如当你在命令行里输入 ls <em>.js,  又或者是你在 .gitignore 文件里写的 bulid/</em> 这些.<br>在解析路径模型的时候, 大括号里用多个逗号隔开的内容会被展开, 里面的部分也可以包含”/“ ,比如  <code>a{/b/c, bcd}</code>  会被展开成 <code>a/b/c</code> 和 <code>abcd</code></p>
<h2 id="路径中的某一段可以使用下面的这些字符表示-他们各自都有很炫的作用"><a href="#路径中的某一段可以使用下面的这些字符表示-他们各自都有很炫的作用" class="headerlink" title="路径中的某一段可以使用下面的这些字符表示,他们各自都有很炫的作用:"></a>路径中的某一段可以使用下面的这些字符表示,他们各自都有很炫的作用:</h2><h3 id="1-匹配该路径段中0个或多个任意字符"><a href="#1-匹配该路径段中0个或多个任意字符" class="headerlink" title="1. * : 匹配该路径段中0个或多个任意字符:"></a>1. * : 匹配该路径段中0个或多个任意字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*:匹配路径中某部分:0个或多个字符</span></div><div class="line">glob(<span class="string">"js/*.js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取js目录下的所有js文件.(不包括以’.’开头的文件)</p>
<h3 id="2-匹配该路径段中1个任意字符"><a href="#2-匹配该路径段中1个任意字符" class="headerlink" title="2. ? : 匹配该路径段中1个任意字符:"></a>2. ? : 匹配该路径段中1个任意字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//?:匹配路径中某部分:1个字符</span></div><div class="line">glob(<span class="string">"js/?.js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取js目录下所有名字只有1个字的js.</p>
<h3 id="3-…-匹配该路径段中在指定范围内字符"><a href="#3-…-匹配该路径段中在指定范围内字符" class="headerlink" title="3. […] : 匹配该路径段中在指定范围内字符:"></a>3. […] : 匹配该路径段中在指定范围内字符:</h3><p>注意不能组合,只能是其中一个字符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[]:匹配路径中某部分:指定的范围</span></div><div class="line">glob(<span class="string">"js/a[0-3].js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a开头,第二个字符为0-3之间(包括0和3)的js(a03.js不能被匹配到)</p>
<h3 id="4-pattern-pattern-pattern-匹配括号中多个模型的0个或多个或任意个的组合"><a href="#4-pattern-pattern-pattern-匹配括号中多个模型的0个或多个或任意个的组合" class="headerlink" title="4. *(pattern|pattern|pattern) : 匹配括号中多个模型的0个或多个或任意个的组合"></a>4. *(pattern|pattern|pattern) : 匹配括号中多个模型的0个或多个或任意个的组合</h3><p>注意|前后不能有空格<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的0个或多个.</span></div><div class="line"><span class="comment">//除了三个模型本身,如果是组合也可以,比如ab.js,但是仅仅包含某个模型是不行的,比如a4.js.</span></div><div class="line">glob(<span class="string">"js/*(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a.js,a1.js,b.js,或者a,a1,b这几个字符的组合的js,比如ab.js</p>
<h3 id="5-pattern-pattern-pattern-匹配不包含任何模型"><a href="#5-pattern-pattern-pattern-匹配不包含任何模型" class="headerlink" title="5. !(pattern|pattern|pattern) : 匹配不包含任何模型"></a>5. !(pattern|pattern|pattern) : 匹配不包含任何模型</h3><p>需要注意: !(pattern|pattern|pattern)  不等于 !(*(pattern|pattern|pattern))<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//!(pattern|pattern|pattern): 匹配路径中的某部分: 不包含任何模型.</span></div><div class="line"><span class="comment">//带有a或者b的,都排除.需要注意的是,它并非是*(a|b)的取反</span></div><div class="line">glob(<span class="string">"js/!(a|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下名字中不包含a,也不包含b的所有文件.</p>
<h3 id="6-pattern-pattern-pattern-匹配多个模型中的0个或任意1个"><a href="#6-pattern-pattern-pattern-匹配多个模型中的0个或任意1个" class="headerlink" title="6. ?(pattern|pattern|pattern) : 匹配多个模型中的0个或任意1个."></a>6. ?(pattern|pattern|pattern) : 匹配多个模型中的0个或任意1个.</h3><p>它和 4 的区别是,不可以组合.必须完全匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//?(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的0个或1个.</span></div><div class="line"><span class="comment">//精确匹配模型,不可以组合.</span></div><div class="line">glob(<span class="string">"js/?(a|a2|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a.js,a2.js,b.js</p>
<h3 id="7-pattern-pattern-pattern-匹配多个模型中的1个或多个"><a href="#7-pattern-pattern-pattern-匹配多个模型中的1个或多个" class="headerlink" title="7. +(pattern|pattern|pattern) : 匹配多个模型中的1个或多个."></a>7. +(pattern|pattern|pattern) : 匹配多个模型中的1个或多个.</h3><p>它和 4 的区别是,必须有一个,为空不匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//+(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的1个或多个.</span></div><div class="line"><span class="comment">//可以是任意一个模型,也可以是他们的组合,比如ab.js</span></div><div class="line">glob(<span class="string">"js/+(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="8-pattern-pat-pat-erN-匹配多个模型中的任意1个"><a href="#8-pattern-pat-pat-erN-匹配多个模型中的任意1个" class="headerlink" title="8. @(pattern|pat*|pat?erN) : 匹配多个模型中的任意1个."></a>8. @(pattern|pat*|pat?erN) : 匹配多个模型中的任意1个.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的1个.</span></div><div class="line"><span class="comment">//精确匹配模型,不可以组合.和?的区别就是不可以为空.必须要是其中的一个.</span></div><div class="line">glob(<span class="string">"js/@(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>和 6 的区别是不匹配为空的情况</p>
<h3 id="9-和-1-一样-可以匹配任何内容-但不仅匹配路径中的某一段-而且可以匹配-‘a-b-c’-这样带有’-‘的内容-所以-它还可以匹配子文件夹下的文件"><a href="#9-和-1-一样-可以匹配任何内容-但不仅匹配路径中的某一段-而且可以匹配-‘a-b-c’-这样带有’-‘的内容-所以-它还可以匹配子文件夹下的文件" class="headerlink" title="9.  : 和 1 一样,可以匹配任何内容,但不仅匹配路径中的某一段,而且可以匹配 ‘a/b/c’ 这样带有’/‘的内容,所以,它还可以匹配子文件夹下的文件."></a>9. <strong> : 和 1 一样,可以匹配任何内容,但</strong>不仅匹配路径中的某一段,而且可以匹配 ‘a/b/c’ 这样带有’/‘的内容,所以,它还可以匹配子文件夹下的文件.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//**: 不是一个单独的路径中的某部分,而是可以带有'/',所以所有当前文件夹和子文件夹下都进行匹配</span></div><div class="line">glob(<span class="string">"**/@(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取当前目录所有文件夹及子文件夹下的a.js,a1.js,b.js<br>还有一种方式是设置 <code>matchBase</code> 属性为<code>true</code> ,同样可以起到在当前路径下搜索所有子文件夹的效果:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//matchBase: 设置为true以后,在当前目录下所有的文件夹和子文件夹里寻找匹配的文件</span></div><div class="line">glob(<span class="string">"@(a|a1|b).js"</span>,&#123;<span class="attr">matchBase</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="没有获取到任何匹配文件"><a href="#没有获取到任何匹配文件" class="headerlink" title="没有获取到任何匹配文件:"></a>没有获取到任何匹配文件:</h3><p>当glob没有获取到任何匹配的文件是,并不会像shell里那样返回模型本身,files参数返回的是一个空数组,如果需要让files返回的是模型本身,需要设置 <code>nonull</code> 属性为 <code>true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//nonull: 设置为true以后,如果没有找到匹配的文件,不返回空字符串,而是返回原始glob语句</span></div><div class="line">glob(<span class="string">"@(c|d|e).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="同步获取匹配文件列表"><a href="#同步获取匹配文件列表" class="headerlink" title="同步获取匹配文件列表:"></a>同步获取匹配文件列表:</h3><p>前面讲到的都是异步的方法,传入一个回调,当获取到匹配的文件的时候执行回调.如果需要同步的获取文件列表,可以这样做:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> files = glob.sync(pattern, [options])</div></pre></td></tr></table></figure></p>
<h2 id="Glob类"><a href="#Glob类" class="headerlink" title="Glob类:"></a>Glob类:</h2><p>通过实例化一个glob.Glob类,可以获得一个glob对象:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Glob = <span class="built_in">require</span>(<span class="string">"glob"</span>).Glob</div><div class="line"><span class="keyword">var</span> mg = <span class="keyword">new</span> Glob(pattern, options, cb)</div></pre></td></tr></table></figure></p>
<p>实例化的时候传入的参数和glob(pattern,options,cb)是一样的.<br>它能够得到一个返回值,这个返回值是一个EventEmitter.<br>如果在选项中设置 <code>sync</code> 属性为 <code>true</code>, 表示同步获取.不可以传入cb回调. 要获取匹配结果,可以通过 <code>g.found</code> 来获取:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globInstance = <span class="keyword">new</span> glob.Glob(<span class="string">"@(a|a1|b).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>,<span class="attr">matchBase</span>:<span class="literal">true</span>,<span class="attr">sync</span>:<span class="literal">true</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(globInstance.found);</div></pre></td></tr></table></figure></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件:"></a>事件:</h3><ul>
<li>end :  end事件会在文件匹配结束,找出所有匹配结果的时候触发,它接受的参数就是找到的文件的数组</li>
<li>match :  match事件会在每次匹配到一个文件的时候触发,它接受的参数就是匹配到的文件</li>
<li>error :  error事件会在匹配遇到错误的时候触发.接受的参数就是错误信息</li>
<li>abort :  当实例调用了.abort()方法时,abort事件被触发</li>
</ul>
<p>###　方法:</p>
<ul>
<li>pause 暂停匹配搜索</li>
<li>resume 继续匹配搜索</li>
<li>abort 永远停止匹配搜索,不能继续<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globInstance = <span class="keyword">new</span> glob.Glob(<span class="string">"js/@(a|a1|b).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>&#125;);</div><div class="line">globInstance.on(<span class="string">'match'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(file)</div><div class="line">&#125;);</div><div class="line">globInstance.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">files</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;);</div><div class="line">globInstance.on(<span class="string">'abort'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'abort'</span>)</div><div class="line">&#125;);</div><div class="line">globInstance.pause();</div><div class="line">globInstance.resume();</div><div class="line">globInstance.abort();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h3><ul>
<li>minimatch glob所使用的minimatch对象.</li>
<li>options 传递给函数的options选项.</li>
<li>aborted 调用过abort()函数后它的值就是true.</li>
<li>cache</li>
<li>statCache</li>
<li>symlinks</li>
<li>realpathCache </li>
</ul>
<h3 id="options选项"><a href="#options选项" class="headerlink" title="options选项:"></a>options选项:</h3><p>options用于配置模型匹配时候的匹配方式. 所有可以被传入到minimatch里的参数也都可以被传入到glob,另外node-glob还自己添加了一些配置项.</p>
<p>所有的选项如果没有特殊说明,默认值都是false</p>
<p>所有的选项也都适用于Glob类.</p>
<ul>
<li>cwd :检索目录</li>
<li>root </li>
<li>dot </li>
<li>nomount </li>
<li>mark</li>
<li>nosort </li>
<li>stat</li>
<li>… </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.&lt;br&gt;这个glob工具基于javascript.它使用了 minimatch 库来进行匹配&lt;br&gt;&lt;a href=&quot;https://github.com/isaacs/node-glob&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>inquirer.js-常见的交互式命令行用户接口的集合</title>
    <link href="http://html-js.site/2017/05/31/inquirer-js-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>http://html-js.site/2017/05/31/inquirer-js-常见的交互式命令行用户接口的集合/</id>
    <published>2017-05-31T02:46:27.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建交互式命令行用户接口<br><img src="/images/page/inquirer/1.png" alt=""></p>
<p>github地址： <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="external">https://github.com/SBoudrias/Inquirer.js</a></p>
<a id="more"></a>
<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install inquirer</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);</div><div class="line">inquirer.prompt([<span class="comment">/* Pass your questions in here */</span>]).then(<span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">	<span class="comment">// Use user feedback for... whatever!!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Pizza delivery prompt example</div><div class="line"> * run example by writing `node pizza.js` in your console</div><div class="line"> */</div><div class="line"><span class="meta"></span></div><div class="line">'use strict';</div><div class="line"><span class="keyword">var</span> inquirer = <span class="built_in">require</span>(<span class="string">'..'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hi, welcome to Node Pizza'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> questions = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'confirm'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'toBeDelivered'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'Is this for delivery?'</span>,</div><div class="line">    <span class="attr">default</span>: <span class="literal">false</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'input'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'phone'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'What\'s your phone number?'</span>,</div><div class="line">    <span class="attr">validate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> pass = value.match(<span class="regexp">/^([01]&#123;1&#125;)?[-.\s]?\(?(\d&#123;3&#125;)\)?[-.\s]?(\d&#123;3&#125;)[-.\s]?(\d&#123;4&#125;)\s?((?:#|ext\.?\s?|x\.?\s?)&#123;1&#125;(?:\d+)?)?$/i</span>);</div><div class="line">      <span class="keyword">if</span> (pass) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="string">'Please enter a valid phone number'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'list'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'size'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'What size do you need?'</span>,</div><div class="line">    <span class="attr">choices</span>: [<span class="string">'Large'</span>, <span class="string">'Medium'</span>, <span class="string">'Small'</span>],</div><div class="line">    <span class="attr">filter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> val.toLowerCase();</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'input'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'quantity'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'How many do you need?'</span>,</div><div class="line">    <span class="attr">validate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> valid = !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(value));</div><div class="line">      <span class="keyword">return</span> valid || <span class="string">'Please enter a number'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">filter</span>: <span class="built_in">Number</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'expand'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'toppings'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'What about the toppings?'</span>,</div><div class="line">    <span class="attr">choices</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">key</span>: <span class="string">'p'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'Pepperoni and cheese'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'PepperoniCheese'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">key</span>: <span class="string">'a'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'All dressed'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'alldressed'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">key</span>: <span class="string">'w'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'Hawaiian'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'hawaiian'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'rawlist'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'beverage'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'You also get a free 2L beverage'</span>,</div><div class="line">    <span class="attr">choices</span>: [<span class="string">'Pepsi'</span>, <span class="string">'7up'</span>, <span class="string">'Coke'</span>]</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'input'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'comments'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'Any comments on your purchase experience?'</span>,</div><div class="line">    <span class="attr">default</span>: <span class="string">'Nope, all good!'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'list'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'prize'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'For leaving a comment, you get a freebie'</span>,</div><div class="line">    <span class="attr">choices</span>: [<span class="string">'cake'</span>, <span class="string">'fries'</span>],</div><div class="line">    <span class="attr">when</span>: <span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> answers.comments !== <span class="string">'Nope, all good!'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line">inquirer.prompt(questions).then(<span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'\nOrder receipt:'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(answers, <span class="literal">null</span>, <span class="string">'  '</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行效果：<br><img src="/images/page/inquirer/2.png" alt=""><br><img src="/images/page/inquirer/3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建交互式命令行用户接口&lt;br&gt;&lt;img src=&quot;/images/page/inquirer/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;github地址： &lt;a href=&quot;https://github.com/SBoudrias/Inquirer.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SBoudrias/Inquirer.js&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="nodejs" scheme="http://html-js.site/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>commander.js-node.js 命令行接口的完整解决方案</title>
    <link href="http://html-js.site/2017/05/26/commander-js-node-js-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://html-js.site/2017/05/26/commander-js-node-js-命令行接口的完整解决方案/</id>
    <published>2017-05-26T01:52:17.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Commander-js"><a href="#Commander-js" class="headerlink" title="Commander.js"></a>Commander.js</h1><p><a href="http://nodejs.org" target="_blank" rel="external">node.js</a> 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。<br><a href="http://tj.github.com/commander.js/" target="_blank" rel="external">API 文档</a><br>本文所有的例子都可以用 <code>node name.js &lt;command/option&gt;</code> 执行<br>吐槽：commander.js中文文档真的好难找哇<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install commander</div></pre></td></tr></table></figure>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>定义并使用 commander 的选项功能 <code>.option()</code> 方法。作为这些选项的文档，下面的例子会解析来自 <code>progress.argv</code> 指定的参数和选项，留下剩余未被选择的参数放到 <code>program.args</code> 数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Module dependencies.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-p, --peppers'</span>, <span class="string">'Add peppers'</span>)</div><div class="line">  .option(<span class="string">'-P, --pineapple'</span>, <span class="string">'Add pineapple'</span>)</div><div class="line">  .option(<span class="string">'-b, --bbq-sauce'</span>, <span class="string">'Add bbq sauce'</span>)</div><div class="line">  .option(<span class="string">'-c, --cheese [type]'</span>, <span class="string">'Add the specified type of cheese [marble]'</span>, <span class="string">'marble'</span>)</div><div class="line">  .parse(process.argv);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'you ordered a pizza with:'</span>);</div><div class="line"><span class="keyword">if</span> (program.peppers) <span class="built_in">console</span>.log(<span class="string">'  - peppers'</span>);</div><div class="line"><span class="keyword">if</span> (program.pineapple) <span class="built_in">console</span>.log(<span class="string">'  - pineapple'</span>);</div><div class="line"><span class="keyword">if</span> (program.bbqSauce) <span class="built_in">console</span>.log(<span class="string">'  - bbq'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'  - %s cheese'</span>, program.cheese);</div></pre></td></tr></table></figure></p>
<p>短标志可以作为单独的参数传递。像 <code>-abc</code> 等于 <code>-a -b -c</code>。多词组成的选项，像“–template-engine”会变成 <code>program.templateEngine</code> 等。</p>
<h2 id="强制多态"><a href="#强制多态" class="headerlink" title="强制多态"></a>强制多态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val.split(<span class="string">'..'</span>).map(<span class="built_in">Number</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val.split(<span class="string">','</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params">val, memo</span>) </span>&#123;</div><div class="line">  memo.push(val);</div><div class="line">  <span class="keyword">return</span> memo;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseVerbosity</span>(<span class="params">v, total</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> total + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .usage(<span class="string">'[options] &lt;file ...&gt;'</span>)</div><div class="line">  .option(<span class="string">'-i, --integer &lt;n&gt;'</span>, <span class="string">'An integer argument'</span>, <span class="built_in">parseInt</span>)</div><div class="line">  .option(<span class="string">'-f, --float &lt;n&gt;'</span>, <span class="string">'A float argument'</span>, <span class="built_in">parseFloat</span>)</div><div class="line">  .option(<span class="string">'-r, --range &lt;a&gt;..&lt;b&gt;'</span>, <span class="string">'A range'</span>, range)</div><div class="line">  .option(<span class="string">'-l, --list &lt;items&gt;'</span>, <span class="string">'A list'</span>, list)</div><div class="line">  .option(<span class="string">'-o, --optional [value]'</span>, <span class="string">'An optional value'</span>)</div><div class="line">  .option(<span class="string">'-c, --collect [value]'</span>, <span class="string">'A repeatable value'</span>, collect, [])</div><div class="line">  .option(<span class="string">'-v, --verbose'</span>, <span class="string">'A value that can be increased'</span>, increaseVerbosity, <span class="number">0</span>)</div><div class="line">  .parse(process.argv);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">' int: %j'</span>, program.integer);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' float: %j'</span>, program.float);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' optional: %j'</span>, program.optional);</div><div class="line">program.range = program.range || [];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' range: %j..%j'</span>, program.range[<span class="number">0</span>], program.range[<span class="number">1</span>]);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' list: %j'</span>, program.list);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' collect: %j'</span>, program.collect);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' verbosity: %j'</span>, program.verbose);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' args: %j'</span>, program.args);</div></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-s --size &lt;size&gt;'</span>, <span class="string">'Pizza size'</span>, /^(large|medium|small)$/i, <span class="string">'medium'</span>)</div><div class="line">  .option(<span class="string">'-d --drink [drink]'</span>, <span class="string">'Drink'</span>, /^(coke|pepsi|izze)$/i)</div><div class="line">  .parse(process.argv);</div><div class="line">  </div><div class="line"><span class="built_in">console</span>.log(<span class="string">' size: %j'</span>, program.size);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' drink: %j'</span>, program.drink);</div></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>一个命令的最后一个参数可以是可变参数, 并且只能是最后一个参数。为了使参数可变，你需要在参数名后面追加 …。 下面是个示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Module dependencies.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .command(<span class="string">'rmdir &lt;dir&gt; [otherDirs...]'</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span> (<span class="params">dir, otherDirs</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rmdir %s'</span>, dir);</div><div class="line">    <span class="keyword">if</span> (otherDirs) &#123;</div><div class="line">      otherDirs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">oDir</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'rmdir %s'</span>, oDir);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div></pre></td></tr></table></figure></p>
<p>数组 是可以用于给可变参数传值的。 这适用于 <code>program.args</code> 以及参数传递，以你的行动证明上述。 你可以如上所示的去尝试。</p>
<h2 id="指定参数的语法"><a href="#指定参数的语法" class="headerlink" title="指定参数的语法"></a>指定参数的语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'../'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .arguments(<span class="string">'&lt;cmd&gt; [env]'</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span> (<span class="params">cmd, env</span>) </span>&#123;</div><div class="line">     cmdValue = cmd;</div><div class="line">     envValue = env;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> cmdValue === <span class="string">'undefined'</span>) &#123;</div><div class="line">   <span class="built_in">console</span>.error(<span class="string">'no command given!'</span>);</div><div class="line">   process.exit(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'command:'</span>, cmdValue);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'environment:'</span>, envValue || <span class="string">"no environment given"</span>);</div></pre></td></tr></table></figure>
<h2 id="Git-风格的子命令"><a href="#Git-风格的子命令" class="headerlink" title="Git 风格的子命令"></a>Git 风格的子命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file: ./examples/pm</span></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'..'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .command(<span class="string">'install [name]'</span>, <span class="string">'install one or more packages'</span>)</div><div class="line">  .command(<span class="string">'search [query]'</span>, <span class="string">'search with optional query'</span>)</div><div class="line">  .command(<span class="string">'list'</span>, <span class="string">'list packages installed'</span>, &#123;<span class="attr">isDefault</span>: <span class="literal">true</span>&#125;)</div><div class="line">  .parse(process.argv);</div></pre></td></tr></table></figure>
<p>当说明参数调用 <code>.command()</code> 时，没有 <code>.action(callback)</code> 应调用来处理子命令，否则会出错。这告诉 <code>commander</code>，你要使用单独的可执行文件的子命令，就像 <code>git(1)</code> 和其他流行工具一样。 <code>Commander</code> 将尝试在入口脚本的目录中搜索可执行文件，（像<code>./examples/pm</code>）与名称 <code>program-command</code>，像 <code>pm-install</code>，<code>pm-search</code>。</p>
<p>对 <code>.command()</code> 的调用，可以传递选项。指定 <code>opts.noHelp</code> 为 <code>true</code> 将从生成的帮助输出中删除选项。如果没有其他子命令指定，指定 <code>opts.isDefault</code> 为 <code>true</code> 将运行子命令。</p>
<p>如果打算全局<code>（--global）</code>安装该命令，请确保可执行文件有适当的模式，如 <code>&#39;755&#39;</code>。</p>
<h3 id="–harmony"><a href="#–harmony" class="headerlink" title="–harmony"></a>–harmony</h3><p>您可以启用 <code>--harmoney</code> 选项在两个方面：</p>
<ul>
<li>用 #!/usr/bin/env node –harmony 在子命令脚本中。注意一些系统版本不支持此模式。</li>
<li>用 –harmoney 选项时调用的命令，像 node –harmony examples/pm publish。–harmoney 选项当产生一个子命令进程时保留选项。</li>
</ul>
<h2 id="自动化帮助信息-–help"><a href="#自动化帮助信息-–help" class="headerlink" title="自动化帮助信息 –help"></a>自动化帮助信息 –help</h2><p>帮助信息是 commander 基于你的程序自动生成的，下面是 <code>--help</code> 生成的帮助信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ ./examples/pizza --help</div><div class="line"></div><div class="line">   Usage: pizza [options]</div><div class="line"></div><div class="line">   An application <span class="keyword">for</span> pizzas ordering</div><div class="line"></div><div class="line">   Options:</div><div class="line"></div><div class="line">     -h, --help           output usage information</div><div class="line">     -V, --version        output the version number</div><div class="line">     -p, --peppers        Add peppers</div><div class="line">     -P, --pineapple      Add pineapple</div><div class="line">     -b, --bbq            Add bbq sauce</div><div class="line">     -c, --cheese &lt;type&gt;  Add the specified type <span class="keyword">of</span> cheese [marble]</div><div class="line">     -C, --no-cheese      You <span class="keyword">do</span> not want any cheese</div></pre></td></tr></table></figure></p>
<h2 id="自定义帮助"><a href="#自定义帮助" class="headerlink" title="自定义帮助"></a>自定义帮助</h2><p>你可以显示任何 <code>-h</code>, <code>--help</code> 信息，通过监听 <code>--help</code> 。一旦你完成了 Commander 将自动退出，你的程序的其余部分不会展示。例如在下面的 “stuff” 将不会在执行 <code>--help</code> 时输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Module dependencies.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-f, --foo'</span>, <span class="string">'enable some foo'</span>)</div><div class="line">  .option(<span class="string">'-b, --bar'</span>, <span class="string">'enable some bar'</span>)</div><div class="line">  .option(<span class="string">'-B, --baz'</span>, <span class="string">'enable some baz'</span>);</div><div class="line"></div><div class="line"><span class="comment">// must be before .parse() since</span></div><div class="line"><span class="comment">// node's emit() is immediate</span></div><div class="line"></div><div class="line">program.on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'  Examples:'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'    $ custom-help --help'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'    $ custom-help -h'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</div></pre></td></tr></table></figure></p>
<p>下列帮助信息是运行 <code>node script-name.js -h</code> or <code>node script-name.js --help</code> 时输出的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Usage: custom-help [options]</div><div class="line"></div><div class="line">Options:</div><div class="line"></div><div class="line">  -h, --help     output usage information</div><div class="line">  -V, --version  output the version number</div><div class="line">  -f, --foo      enable some foo</div><div class="line">  -b, --bar      enable some bar</div><div class="line">  -B, --baz      enable some baz</div><div class="line"></div><div class="line">Examples:</div><div class="line"></div><div class="line">  $ custom-help --help</div><div class="line">  $ custom-help -h</div></pre></td></tr></table></figure></p>
<h3 id="outputHelp-cb"><a href="#outputHelp-cb" class="headerlink" title=".outputHelp(cb)"></a>.outputHelp(cb)</h3><p>不退出输出帮助信息。 可选的回调可在显示帮助文本后处理。 如果你想显示默认的帮助（例如，如果没有提供命令），你可以使用类似的东西：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"><span class="keyword">var</span> colors = <span class="built_in">require</span>(<span class="string">'colors'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .command(<span class="string">'getstream [url]'</span>, <span class="string">'get stream URL'</span>)</div><div class="line">  .parse(process.argv);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!process.argv.slice(<span class="number">2</span>).length) &#123;</div><div class="line">    program.outputHelp(make_red);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_red</span>(<span class="params">txt</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> colors.red(txt); <span class="comment">// 在控制台上显示红色的帮助文本</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="help-cb"><a href="#help-cb" class="headerlink" title=".help(cb)"></a>.help(cb)</h3><p>输出帮助信息并立即退出。 可选的回调可在显示帮助文本后处理。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-C, --chdir &lt;path&gt;'</span>, <span class="string">'change the working directory'</span>)</div><div class="line">  .option(<span class="string">'-c, --config &lt;path&gt;'</span>, <span class="string">'set config path. defaults to ./deploy.conf'</span>)</div><div class="line">  .option(<span class="string">'-T, --no-tests'</span>, <span class="string">'ignore test hook'</span>)</div><div class="line"></div><div class="line">program</div><div class="line">  .command(<span class="string">'setup [env]'</span>)</div><div class="line">  .description(<span class="string">'run setup commands for all envs'</span>)</div><div class="line">  .option(<span class="string">"-s, --setup_mode [mode]"</span>, <span class="string">"Which setup mode to use"</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span>(<span class="params">env, options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> mode = options.setup_mode || <span class="string">"normal"</span>;</div><div class="line">    env = env || <span class="string">'all'</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setup for %s env(s) with %s mode'</span>, env, mode);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program</div><div class="line">  .command(<span class="string">'exec &lt;cmd&gt;'</span>)</div><div class="line">  .alias(<span class="string">'ex'</span>)</div><div class="line">  .description(<span class="string">'execute the given remote cmd'</span>)</div><div class="line">  .option(<span class="string">"-e, --exec_mode &lt;mode&gt;"</span>, <span class="string">"Which exec mode to use"</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span>(<span class="params">cmd, options</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'exec "%s" using %s mode'</span>, cmd, options.exec_mode);</div><div class="line">  &#125;).on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'  Examples:'</span>);</div><div class="line">    <span class="built_in">console</span>.log();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'    $ deploy exec sequential'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'    $ deploy exec async'</span>);</div><div class="line">    <span class="built_in">console</span>.log();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program</div><div class="line">  .command(<span class="string">'*'</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span>(<span class="params">env</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'deploying "%s"'</span>, env);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div></pre></td></tr></table></figure>
<p>更多的 <a href="https://github.com/tj/commander.js/tree/master/examples" target="_blank" rel="external">演示 </a>可以在这里找到.</p>
<p>参考链接：<br><a href="https://github.com/tj/commander.js" target="_blank" rel="external">commander.js github项目地址</a><br><a href="https://github.com/tj/commander.js/blob/master/Readme_zh-CN.md" target="_blank" rel="external">commander.js 中文文档</a><br><a href="http://tj.github.io/commander.js/" target="_blank" rel="external">commander.js api</a><br><a href="http://zhiye.li/2015-01-15-intro-to-commander.js-zh-cn.html" target="_blank" rel="external">使用commander.js创建nodejs命令行工具 by zhiyelee</a><br><a href="http://blog.fens.me/nodejs-commander/" target="_blank" rel="external">Commander写自己的Nodejs命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Commander-js&quot;&gt;&lt;a href=&quot;#Commander-js&quot; class=&quot;headerlink&quot; title=&quot;Commander.js&quot;&gt;&lt;/a&gt;Commander.js&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node.js&lt;/a&gt; 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。&lt;br&gt;&lt;a href=&quot;http://tj.github.com/commander.js/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API 文档&lt;/a&gt;&lt;br&gt;本文所有的例子都可以用 &lt;code&gt;node name.js &amp;lt;command/option&amp;gt;&lt;/code&gt; 执行&lt;br&gt;吐槽：commander.js中文文档真的好难找哇&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>当你不知道干什么的时候，可以看看这些</title>
    <link href="http://html-js.site/2017/05/22/%E5%BD%93%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%BA%9B/"/>
    <id>http://html-js.site/2017/05/22/当你不知道干什么的时候，可以看看这些/</id>
    <published>2017-05-22T09:15:38.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可以看看电影视频"><a href="#可以看看电影视频" class="headerlink" title="可以看看电影视频"></a>可以看看电影视频</h2><p><a href="https://movie.douban.com/top250" target="_blank" rel="external">豆瓣电影250</a> 随便挑一个都是百看不厌<br><a href="http://open.163.com/" target="_blank" rel="external">网易公开课</a> 不带目的随便看几个ted<br><a href="http://letshareba.com/movie" target="_blank" rel="external">最近正在热映电影</a> 可以看看评分，然后去电影院看看</p>
<h2 id="可以看看知乎"><a href="#可以看看知乎" class="headerlink" title="可以看看知乎"></a>可以看看知乎</h2><p><a href="https://www.zhihu.com/collection/37406996" target="_blank" rel="external">知乎5000斩</a> 都是5K赞以上的回答</p>
<a id="more"></a>
<h2 id="可以开发些小工具"><a href="#可以开发些小工具" class="headerlink" title="可以开发些小工具"></a>可以开发些小工具</h2><p><a href="https://leetcode.com/" target="_blank" rel="external">leetcode</a> 做几道题，消磨下时间<br><a href="https://www.zhihu.com/question/36132174/answer/70798699" target="_blank" rel="external">爬虫可以干什么</a> 可以开发些有趣的东西<br><a href="https://www.zhihu.com/question/27621722" target="_blank" rel="external">能利用爬虫技术做到哪些很酷很有趣很有用的事情？</a> 有些真是脑洞大开<br><a href="http://www.ishuchao.com/topic/294" target="_blank" rel="external">V2EX上最值得收藏的100个话题</a> 有好多可以自己实现下<br><a href="http://www.pythonchallenge.com/" target="_blank" rel="external">python challenge</a> 至今还未通关的python挑战</p>
<h2 id="可以看看大神们的博客"><a href="#可以看看大神们的博客" class="headerlink" title="可以看看大神们的博客"></a>可以看看大神们的博客</h2><blockquote>
<p>放些我经常看的博主们</p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰</a> 阮老师<br><a href="http://coolshell.cn/" target="_blank" rel="external">酷壳</a> 左耳朵耗子<br><a href="http://mindhacks.cn/" target="_blank" rel="external">刘未鹏</a> 思维改变生活<br><a href="http://blog.csdn.net/v_JULY_v" target="_blank" rel="external">July</a> 看看题解和思路<br><a href="https://www.byvoid.com/" target="_blank" rel="external">byVoid</a> 算法，node，c++大神<br><a href="http://www.zhangxinxu.com/wordpress/" target="_blank" rel="external">张鑫旭</a> css大神<br><a href="http://www.cnblogs.com/aaronjs/" target="_blank" rel="external">Aaron</a> 以大多数人的努力程度之低，根本轮不到拼天赋<br><a href="http://www.cnblogs.com/yexiaochai" target="_blank" rel="external">叶小钗</a> 开始新的旅途<br><a href="http://barretlee.com/" target="_blank" rel="external">李靖</a> 小胡子哥<br><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔</a> 每次看都有不同的体会</p>
<h2 id="这里收藏些开发工具类"><a href="#这里收藏些开发工具类" class="headerlink" title="这里收藏些开发工具类"></a>这里收藏些开发工具类</h2><blockquote>
<p>这里放些我开发生活经常用到的工具类网站</p>
</blockquote>
<p><a href="https://tinypng.com/" target="_blank" rel="external">图片在线压缩</a><br><a href="http://tool.chinaz.com/regex/?jdfwkey=lskex1" target="_blank" rel="external">正则表达式</a></p>
<h2 id="找找好用的Mac软件"><a href="#找找好用的Mac软件" class="headerlink" title="找找好用的Mac软件"></a>找找好用的Mac软件</h2><p><a href="http://www.waitsun.com/" target="_blank" rel="external">爱情守望者</a> 网站做得比较良心<br><a href="https://github.com/hzlzh/Best-App" target="_blank" rel="external">Best App</a> 收集&amp;推荐优秀的 Apps/硬件/技巧/周边等 － 感谢jason提供</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可以看看电影视频&quot;&gt;&lt;a href=&quot;#可以看看电影视频&quot; class=&quot;headerlink&quot; title=&quot;可以看看电影视频&quot;&gt;&lt;/a&gt;可以看看电影视频&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://movie.douban.com/top250&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;豆瓣电影250&lt;/a&gt; 随便挑一个都是百看不厌&lt;br&gt;&lt;a href=&quot;http://open.163.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;网易公开课&lt;/a&gt; 不带目的随便看几个ted&lt;br&gt;&lt;a href=&quot;http://letshareba.com/movie&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最近正在热映电影&lt;/a&gt; 可以看看评分，然后去电影院看看&lt;/p&gt;
&lt;h2 id=&quot;可以看看知乎&quot;&gt;&lt;a href=&quot;#可以看看知乎&quot; class=&quot;headerlink&quot; title=&quot;可以看看知乎&quot;&gt;&lt;/a&gt;可以看看知乎&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/collection/37406996&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎5000斩&lt;/a&gt; 都是5K赞以上的回答&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://html-js.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶之路</title>
    <link href="http://html-js.site/2017/05/17/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>http://html-js.site/2017/05/17/前端进阶之路/</id>
    <published>2017-05-17T07:49:24.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近一直忙于项目和业务，略疲惫，好在还是利用空闲学习了不少的东西，自勉</p>
</blockquote>
<h2 id="React和Vue对比"><a href="#React和Vue对比" class="headerlink" title="React和Vue对比"></a>React和Vue对比</h2><p>相同点:</p>
<ul>
<li>数据驱动视图，提供响应式的视图组件</li>
<li>都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范</li>
<li>数据流动单向</li>
<li>都支持服务端渲染</li>
<li>都有支持native的方案，React的<code>React native</code>，Vue的<code>weex</code><a id="more"></a>
不同点：</li>
<li>社区：React社区还是要比vue大很多；</li>
<li>开发模式：React在view层侵入性还是要比Vue大很多的,React严格上只针对MVC的view层，Vue则是MVVM模式的一种实现；</li>
<li>数据绑定：Vue有实现了双向数据绑定，React数据流动是单向的</li>
<li>数据渲染：对于大规模数据渲染，React要比Vue更快，渲染机制启动时候要做的工作比较多；</li>
<li>数据更新方面：Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。React在复杂的应用里有两个选择:<ol>
<li>手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render。 </li>
<li>Components 尽可能都用 pureRenderMixin，然后采用 redux 结构 + Immutable.js；</li>
</ol>
</li>
<li>开发风格的偏好：React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即”all in js”；Vue进阶之后推荐的是使用 webpack + vue-loader 的单文件组件格式，即html,css,js写在同一个文件；</li>
<li>使用场景：React配合Redux架构适合超大规模多人协作的复杂项目;Vue则适合小快灵的项目。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React；</li>
<li>Vue要比React更好上手，具体可能体现在很多人不熟悉React的JSX语法和函数式编程的思想，以及想要发挥出React的最大威力需要学习它一系列生态的缘故；</li>
<li>Vue着重提高开发效率,让前端程序员更快速方便的开发应用。React着重于变革开发思想，提升前端程序员编程的深度与创造力,让前端工程师成为真正的程序员而不是UI的构建者；</li>
</ul>
<h2 id="gulp和webpack区别"><a href="#gulp和webpack区别" class="headerlink" title="gulp和webpack区别"></a>gulp和webpack区别</h2><p>gulp是一种工具，我们可以用它来优化前端的工作流程，比如自动刷新页面、combo、压缩css、js、编译less等等。具体体现为：在gulp的配置文件中书写一个个的task，webpack则是一种打包工具，或者说是一种模块化解决方案，实际上很大一部分人刚开始使用webpack的方式就是通过gulp-webpack这个插件，写好task来使用webpack对前端的一些文件进行打包;<br>gulp的处理任务需要自己去写，webpack则有现成的解决方案，只需要在webpack.config.js配置好即可;</p>
<h2 id="防止重复发送Ajax请求"><a href="#防止重复发送Ajax请求" class="headerlink" title="防止重复发送Ajax请求"></a>防止重复发送Ajax请求</h2><p>用户点击之后按钮disabled;<br>函数节流<br>abort掉上一个请求。</p>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><ul>
<li>事件捕获阶段(capturing phase)。事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
<li>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</li>
<li>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ul>
<h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><h3 id="Expires策略"><a href="#Expires策略" class="headerlink" title="Expires策略"></a>Expires策略</h3><p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p>
<h3 id="Cache-Control策略"><a href="#Cache-Control策略" class="headerlink" title="Cache-Control策略"></a>Cache-Control策略</h3><p>Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器是否直接从浏览器缓读取数据还是重新发请求到服务器取数据。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于Expires</strong>。</p>
<p>以上是设置缓存时间的两种方法。那么当缓存时间过了咋整呢？有人肯定说了，那就再次发起请求啊，这是对的。问题是如果服务器资源并没有更新呢？比如说我有一个jQuery.js文件已经缓存了，当它的缓存时间到了之后服务器的jQuery.js文件也没有更新，那实际上我们直接使用本地缓存的文件就可以啊！没必要浪费带宽和时间去重新请求一个新的文件啊！这时候我们就需要再进一步看一下HTTP协议里这几个参数的作用了。</p>
<p>###　Last-Modified/If-Modified-Since</p>
<p>首先Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>
<ul>
<li>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间(这个参数是和Cache-Control一起过来的)。</li>
<li>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 <code>If-Modified-Since</code>，表示请求时间。<strong>web服务器收到请求后发现有头If-Modified-Since ，则与被请求资源的最后修改时间进行比对</strong>。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li>
</ul>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h3><p>Etag/If-None-Match也要配合Cache-Control使用。</p>
<ul>
<li>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</li>
<li>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</li>
</ul>
<h3 id="ETag和Last-Modified"><a href="#ETag和Last-Modified" class="headerlink" title="ETag和Last-Modified"></a>ETag和Last-Modified</h3><p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h2 id="Ajax的状态值与HTTP状态码"><a href="#Ajax的状态值与HTTP状态码" class="headerlink" title="Ajax的状态值与HTTP状态码"></a>Ajax的状态值与HTTP状态码</h2><h3 id="Ajax的状态值"><a href="#Ajax的状态值" class="headerlink" title="Ajax的状态值"></a>Ajax的状态值</h3><ul>
<li>0: (未初始化)还没有调用send()方法。</li>
<li>1: (载入)已经调用send()方法，正在派发请求。</li>
<li>2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。</li>
<li>3: (交互)正在解析响应内容。</li>
<li>4: (完成)响应内容已经解析完成，用户可以调用。</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li>200 &amp; OK: 请求成功；</li>
<li>204 &amp; No Content: 请求处理成功，但没有资源可以返回；</li>
<li>206 &amp; Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)；</li>
<li>301 &amp; Move Permanently: 永久性重定向；</li>
<li>302 &amp; Found： 临时性重定向；</li>
<li>303 &amp; See Other: 请求资源存在另一个URI，应使用get方法请求；</li>
<li>304 &amp; Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存；</li>
<li>307 &amp; Temporary Redirect: 临时重定向；</li>
<li>400 &amp; Bad Request: 请求报文存在语法错误；</li>
<li>401 &amp; Unauthorized: 请求需要通过HTTP认证；</li>
<li>403 &amp; Forbidden: 请求资源被服务器拒绝，访问权限的问题；</li>
<li>404 &amp; Not Found: 服务器上没有请求的资源；</li>
<li>500 &amp; Internal Server Error: 服务器执行请求时出现错误；</li>
<li>502 &amp; Bad Gateway: 错误的网关；</li>
<li>503 &amp; Service Unavailable: 服务器超载或正在维护，无法处理请求；</li>
<li>504 &amp; Gateway timeout: 网关超时；</li>
</ul>
<h2 id="React-router原理"><a href="#React-router原理" class="headerlink" title="React-router原理"></a>React-router原理</h2><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ul>
<li>老浏览器的history: 主要通过hash来实现，对应<code>createHashHistory</code></li>
<li>高版本浏览器: 通过html5里面的history，对应<code>createBrowserHistory</code></li>
<li>node环境下: 主要存储在memeory里面，对应<code>createMemoryHistory</code></li>
</ul>
<p>内部createHistory实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内部的抽象实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHistory</span>(<span class="params">options=&#123;&#125;</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  return &#123;</div><div class="line">    listenBefore, <span class="comment">// 内部的hook机制，可以在location发生变化前执行某些行为，AOP的实现</span></div><div class="line">    listen, <span class="comment">// location发生改变时触发回调</span></div><div class="line">    transitionTo, <span class="comment">// 执行location的改变</span></div><div class="line">    push, <span class="comment">// 改变location</span></div><div class="line">    replace,</div><div class="line">    go,</div><div class="line">    goBack,</div><div class="line">    goForward,</div><div class="line">    createKey, <span class="comment">// 创建location的key，用于唯一标示该location，是随机生成的</span></div><div class="line">    createPath,</div><div class="line">    createHref,</div><div class="line">    createLocation, <span class="comment">// 创建location</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createLocation方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLocation</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    pathname, <span class="comment">// url的基本路径</span></div><div class="line">    search, <span class="comment">// 查询字段</span></div><div class="line">    hash, <span class="comment">// url中的hash值</span></div><div class="line">    state, <span class="comment">// url对应的state字段</span></div><div class="line">    action, <span class="comment">// 分为push、replace、pop三种</span></div><div class="line">    key <span class="comment">// 生成方法为: Math.random().toString(36).substr(2, length)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三种方法各自执行URL前进的方式：</p>
<ul>
<li>createBrowserHistory: pushState、replaceState</li>
<li>createHashHistory: location.hash=<em>*</em> location.replace()</li>
<li>createMemoryHistory: 在内存中进行历史记录的存储</li>
</ul>
<p>伪代码实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// createBrowserHistory(HTML5)中的前进实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  const historyState = &#123; key &#125;;</div><div class="line">  ...</div><div class="line">  if (location.action === <span class="string">'PUSH'</span>) ) &#123;</div><div class="line">    <span class="built_in">window</span>.history.pushState(historyState, <span class="literal">null</span>, path);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.history.replaceState(historyState, <span class="literal">null</span>, path)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// createHashHistory的内部实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  if (location.action === <span class="string">'PUSH'</span>) ) &#123;</div><div class="line">    <span class="built_in">window</span>.location.hash = path;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.location.replace(</div><div class="line">    <span class="built_in">window</span>.location.pathname + <span class="built_in">window</span>.location.search + <span class="string">'#'</span> + path</div><div class="line">  );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// createMemoryHistory的内部实现</span></div><div class="line">entries = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  switch (location.action) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'PUSH'</span>:</div><div class="line">      entries.push(location);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'REPLACE'</span>:</div><div class="line">      entries[current] = location;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="React-router的基本原理"><a href="#React-router的基本原理" class="headerlink" title="React-router的基本原理"></a>React-router的基本原理</h3><p><code>URL</code>对应<code>Location</code>对象，而<code>UI</code>是由<code>react</code>的 <code>components</code>来决定的，这样就转变成<code>location</code>与<code>components</code>之间的同步问题。</p>
<h2 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h2><p>每一个对象都会在内部链接到另一个对象(该对象的原型对象)，该对象有一个原型<code>prototype</code>，当访问对象的属性或是方法的时候，不仅仅会在原对象上查找，还会顺着原型链在原型对象的原型链上查找，直到查到<code>null</code>(所有原型链的顶层)为止。原型是JavaScript实现继承的基础，<code>new</code>关键字做的主要的事情就是将实例对象的<code>__proto__</code>属性指向原型对象的<code>prototype</code>。</p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><ul>
<li>闭包是javascript支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="external">头等函数</a>的一种方式，它是一个能够引用其内部作用域变量(在本作用域第一次声明的变量)的表达式，这个表达式可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</li>
<li>闭包是函数开始执行的时候被分配的一个<a href="http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_" target="_blank" rel="external">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</li>
</ul>
<h3 id="闭包的应用："><a href="#闭包的应用：" class="headerlink" title="闭包的应用："></a>闭包的应用：</h3><ul>
<li><p>比如写柯里化函数的时候利用闭包，保存参数在内存中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</div><div class="line">  	<span class="comment">//格式化arguments</span></div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      	<span class="comment">//收集所有的参数在同一个数组中，进行计算</span></div><div class="line">      	<span class="keyword">var</span> _args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">      	<span class="keyword">return</span> fun.apply(<span class="literal">null</span>, _args);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>模拟私有变量或是私有方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> people = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  	<span class="keyword">var</span> num = num;</div><div class="line">  	<span class="keyword">return</span> &#123;</div><div class="line">    	<span class="attr">increase</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          	num++;</div><div class="line">		&#125;,</div><div class="line">      	<span class="attr">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          	<span class="keyword">return</span> num;</div><div class="line">      	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> man = people(<span class="number">4</span>);</div><div class="line">man.increase();</div><div class="line">man.get();</div></pre></td></tr></table></figure>
</li>
<li><p>避免引用错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">  	(<span class="function"><span class="keyword">function</span>(<span class="params">_i</span>) </span>&#123;</div><div class="line">      	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      		<span class="built_in">console</span>.log(_i)</div><div class="line">		&#125;, <span class="number">1000</span>)</div><div class="line">  	&#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="图片懒加载与预加载"><a href="#图片懒加载与预加载" class="headerlink" title="图片懒加载与预加载"></a>图片懒加载与预加载</h2><ul>
<li>图片懒加载的原理就是暂时不设置图片的<code>src</code>属性，而是将图片的<code>url</code>隐藏起来，比如先写在<code>data-src</code>里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的<code>url</code>放进<code>src</code>属性里面，从而实现图片的延迟加载</li>
<li>图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在css的<code>background</code>的<code>url</code>属性里面，一种是通过javascript的<code>Image</code>对象设置实例对象的<code>src</code>属性实现图片的预加载。相关代码如下：</li>
</ul>
<h3 id="CSS预加载图片方式："><a href="#CSS预加载图片方式：" class="headerlink" title="CSS预加载图片方式："></a>CSS预加载图片方式：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#preload-01</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-01.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;  </div><div class="line"><span class="selector-id">#preload-02</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-02.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;  </div><div class="line"><span class="selector-id">#preload-03</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-03.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;</div></pre></td></tr></table></figure>
<h3 id="Javascript预加载图片的方式："><a href="#Javascript预加载图片的方式：" class="headerlink" title="Javascript预加载图片的方式："></a>Javascript预加载图片的方式：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">preloadImg</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">    img.src = url;</div><div class="line">    <span class="keyword">if</span>(img.complete) &#123;</div><div class="line">        <span class="comment">//接下来可以使用图片了</span></div><div class="line">        <span class="comment">//do something here</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">//接下来可以使用图片了</span></div><div class="line">            <span class="comment">//do something here</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域的方式有很多种，最常用的是<code>jsonp</code>主要利用了<code>script</code>的开放策略:通过<code>script</code>标签引入一个<code>js</code>或者是一个其他后缀形式（如<code>php</code>，<code>jsp</code>等）的文件，此文件返回一个<code>js</code>函数的调用。缺点在于只支持<code>get</code>请求而且存在安全问题。<br><strong>CORS</strong>跨域，关键在于服务器，如果服务器实现了CORS跨域的接口，那么就可以使用ajax(请求路径为绝对路径)进行跨域请求。CORS请求分为两种，一种是简单请求，一种是非简单请求。简单请求是指请求方法在<code>HEAD</code>,<code>GET</code>,<code>POST</code>三者之间并且请求头信息局限在</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
<h3 id="非简单请求请求头："><a href="#非简单请求请求头：" class="headerlink" title="非简单请求请求头："></a>非简单请求请求头：</h3><ul>
<li>（1）Access-Control-Request-Method<br>  该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法</li>
<li>（2）Access-Control-Request-Headers<br>  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段<br>  执行简单请求的时候，浏览器会在请求头信息增加<code>origin</code>字段，服务器据此来判断请求域名是否在许可范围之内，来决定是否返回<code>Access-Control-Allow-Origin</code>字段。响应头有以下几种：<ul>
<li>（1）Access-Control-Allow-Origin<br>  该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>（2）Access-Control-Allow-Credentials<br>  该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</li>
<li>（3）Access-Control-Expose-Headers<br>  该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</li>
<li>(4) Access-Control-Max-Age<br> <code>Access-Control-Max-Age</code> 首部字段指明了预检请求的响应的有效时间。</li>
<li>(5) Access-Control-Allow-Methods<br> <code>Access-Control-Allow-Methods</code> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</li>
<li>(6) Access-Control-Allow-Headers<br> <code>Access-Control-Allow-Headers</code>首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。<br>其他方法：<code>document.domin</code>,<code>html5</code>的<code>postMessage</code>,<code>window.name</code>等</li>
</ul>
</li>
</ul>
<h2 id="函数节流和函数防抖"><a href="#函数节流和函数防抖" class="headerlink" title="函数节流和函数防抖"></a>函数节流和函数防抖</h2><p>函数节流让指函数有规律的进行调用，应用场景：window.resize，游戏中子弹发射(1s只能发射一颗子弹)等；<br>函数防抖让函数在”调用’’之后的一段时间后生效，应用场景:输入框(例：在用户停止输入的500ms后再处理用户数据)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数节流</span></div><div class="line"><span class="comment">/*</span></div><div class="line">* @params &#123;Function&#125; fun 调用函数</div><div class="line">* @params &#123;delay&#125; number 延迟时间</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fun, delay, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> last = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> now = + <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        <span class="keyword">if</span> (now - last &gt; delay) &#123;</div><div class="line">            fun(rest);</div><div class="line">            last = now;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例</span></div><div class="line"><span class="keyword">const</span> throttleExample  = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</div><div class="line"><span class="comment">//调用</span></div><div class="line">throttleExample();</div><div class="line">throttleExample();</div><div class="line">throttleExample();</div><div class="line"><span class="comment">//函数防抖</span></div><div class="line"><span class="keyword">const</span> debouce = <span class="function">(<span class="params">fun, delay, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            fun(rest);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例</span></div><div class="line"><span class="keyword">const</span> debouceExample = debouce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</div><div class="line"><span class="comment">//调用</span></div><div class="line">debouceExample();</div><div class="line">debouceExample();</div><div class="line">debouceExample();</div></pre></td></tr></table></figure></p>
<h2 id="AMD和CMD的区别"><a href="#AMD和CMD的区别" class="headerlink" title="AMD和CMD的区别"></a>AMD和CMD的区别</h2><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
<ul>
<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。</li>
<li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li>
<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</li>
</ul>
<h2 id="JavaScript内存泄露的原因以及如何去手动释放内存"><a href="#JavaScript内存泄露的原因以及如何去手动释放内存" class="headerlink" title="JavaScript内存泄露的原因以及如何去手动释放内存"></a>JavaScript内存泄露的原因以及如何去手动释放内存</h2><h3 id="易出现泄露的场景"><a href="#易出现泄露的场景" class="headerlink" title="易出现泄露的场景"></a>易出现泄露的场景</h3><ul>
<li>XMLHttpRequest 泄漏发生在IE7-8,释放方法，将XMLHttpRequest实例对象设置为Null；</li>
<li>DOM&amp;BOM等COM对象循环绑定 泄漏发生在IE6-8，释放方法，切断循环引用，将对对象的应用设置为Null；</li>
<li>定时器(严格上说不能算是泄露，是被闭包持有了，是正常的表现)，对于闭包中无用的变量可以使用delete操作符进行释放；</li>
</ul>
<h3 id="JavaScript垃圾回收机制"><a href="#JavaScript垃圾回收机制" class="headerlink" title="JavaScript垃圾回收机制"></a>JavaScript垃圾回收机制</h3><ul>
<li>引用计数<br>  此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>  限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</li>
<li>标记清除<br>  当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ul>
<h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h2><p>所谓的柯里化函数简单的说就是将本来接受多个参数的函数变为只接受一个参数的函数。柯里化函数的模板和实例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</div><div class="line">  	<span class="comment">//格式化arguments</span></div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      	<span class="comment">//收集所有的参数在同一个数组中，进行计算</span></div><div class="line">      	<span class="keyword">var</span> _args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">      	<span class="keyword">return</span> fun.apply(<span class="literal">null</span>, _args);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> add = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  	<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 经典面试题</div><div class="line"> * 函数参数不定回调函数数目不定</div><div class="line"> * 编写函数实现:</div><div class="line"> * add(1,2,3,4,5)==15</div><div class="line"> * add(1,2)(3,4)(5)==15</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></div><div class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></div><div class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            [].push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</div><div class="line">            <span class="keyword">return</span> _adder;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></div><div class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> a + b;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> _adder;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> adder.apply(<span class="literal">null</span>, _args);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出结果，可自由组合的参数</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></div></pre></td></tr></table></figure></p>
<h2 id="Less常用特性"><a href="#Less常用特性" class="headerlink" title="Less常用特性"></a>Less常用特性</h2><ul>
<li>变量(@color = #fff)</li>
<li>混合(Mixin)</li>
<li>内置函数(颜色，字符串，类型判断，数学)</li>
<li>循环</li>
<li>嵌套</li>
<li>运算</li>
<li>导入(@import)</li>
</ul>
<h2 id="ES6常用特性"><a href="#ES6常用特性" class="headerlink" title="ES6常用特性"></a>ES6常用特性</h2><ul>
<li>变量定义(let和const,可变与不可变，const定义对象的特殊情况)</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>数组新API(例：Array.from(),entries(),values(),keys())</li>
<li>箭头函数(rest参数，扩展运算符，::绑定this)</li>
<li>Set和Map数据结构(set实例成员值唯一存储key值，map实例存储键值对(key-value))</li>
<li>Promise对象(前端异步解决方案进化史，generator函数，async函数)</li>
<li>Class语法糖(super关键字)</li>
</ul>
<h2 id="react中setState的原理"><a href="#react中setState的原理" class="headerlink" title="react中setState的原理"></a>react中setState的原理</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">value</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">	&#125;, <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//答案: 0、0、0、2、3；</span></div></pre></td></tr></table></figure>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>当<code>setState</code>方法调用的时候<code>React</code>就会重新调用<code>render</code>方法来重新渲染组件；<code>setState</code>通过一个队列来更新<code>state</code>,当调用<code>setState</code>方法的时候会将需要更新的<code>state</code>放入这个状态队列中，这个队列会高效的批量更新<code>state</code>;<br><img src="/images/page/qianduanjinjie/1.svg" alt=""></p>
<p>源码地址:<a href="https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactUpdates.js" target="_blank" rel="external">enqueueUpdate</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  ensureInjected();</div><div class="line">  <span class="comment">//判断是否处于批量更新模式</span></div><div class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class="line">    <span class="comment">//关键！下面的代码片段是这个方法的源码</span></div><div class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果处于批量更新模式，则将这个组件保存在dirtyComponents</span></div><div class="line">  dirtyComponents.push(component);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码地址:<a href="https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactDefaultBatchingStrategy.js" target="_blank" rel="external">ReactDefaultBatchingStrategy</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//batchingStrategy对象</span></div><div class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class="line">  <span class="comment">//注意默认为false</span></div><div class="line">  isBatchingUpdates: <span class="literal">false</span>,</div><div class="line">  <span class="attr">batchedUpdates</span>: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</div><div class="line">      callback(a, b, c, d, e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//关键！！！事务的理解</span></div><div class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>源码地址：<a href="https://github.com/facebook/react/blob/401e6f10587b09d4e725763984957cf309dfdc30/src/shared/utils/Transaction.js" target="_blank" rel="external">Transaction</a><br><img src="/images/page/qianduanjinjie/2.png" alt=""></p>
<p>如图：事务会将所需要执行的方法(图中的<code>anyMethod</code>)使用<code>wrapper</code>封装起来，再通过<code>perform</code>方法执行该方法，但在<code>perform</code>执行之前会先执行所有<code>wrapper</code>中的<code>initialize</code>方法，<code>perform</code>方法执行结束后，再执行所有的<code>close</code>方法；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'./Transaction'</span>);</div><div class="line"><span class="comment">// 我们自己定义的</span></div><div class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="comment">//do something</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</div><div class="line">  	<span class="comment">//需要自定义一个getTransactionWrappers对象，获取所有需要封装的initialize方法和close方法</span></div><div class="line">  	getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </div><div class="line">  		<span class="keyword">return</span> [&#123;      </div><div class="line">          	<span class="attr">initialize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'before method perform'</span>);      </div><div class="line">            &#125;,      </div><div class="line">          	<span class="attr">close</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'after method perform'</span>);      </div><div class="line">            &#125;    </div><div class="line">        &#125;];  </div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//实例化一个transaction</span></div><div class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</div><div class="line"><span class="comment">//需要调用的方法</span></div><div class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line">transaction.perform(testMethod);</div><div class="line"><span class="comment">//before method perform</span></div><div class="line"><span class="comment">//test</span></div><div class="line"><span class="comment">//after method perform</span></div></pre></td></tr></table></figure></p>
<p>理解题目的关键是，整个组件渲染到DOM中的过程就已经处于一次大的事务中了，因此在<code>componentDidMount</code>方法中调用<code>setState</code>的时候<code>ReactDefaultBatchingStrategy.isBatchingUpdates = true</code>;这句代码已经执行过了，所以<code>setState</code>的结果并没有立即生效，而是扔进了<code>dirtyComponent</code>;因此执行三次<code>setState</code>的结果<code>this.state.value</code>的值依然是0,而<code>setTimeout</code>中的两次<code>setState</code>由于没有调用过<code>batchedUpdates</code>方法(<code>isBatchingUpdates</code>默认为<code>false</code>)，所以<code>setState</code>方法立即生效，第二次<code>setSState</code>同理</p>
<h2 id="XSS与CSRF介绍"><a href="#XSS与CSRF介绍" class="headerlink" title="XSS与CSRF介绍"></a>XSS与CSRF介绍</h2><p>XSS是一种跨站脚本攻击，是属于代码注入的一种，攻击者通过将代码注入网页中，其他用户看到会受到影响(代码内容有请求外部服务器);<br>CSRF是一种跨站请求伪造，冒充用户发起请求，完成一些违背用户请求的行为(删帖，改密码，发邮件，发帖等)<br>防御方法举例:<br>    对一些关键字和特殊字符进行过滤(&lt;&gt;,?,script等)，或对用户输入内容进行URL编码(encodeURIComponent);<br>    Cookie不要存放用户名和密码，对cookie信息进行MD5等算法散列存放，必要时可以将IP和cookie绑定;</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近一直忙于项目和业务，略疲惫，好在还是利用空闲学习了不少的东西，自勉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;React和Vue对比&quot;&gt;&lt;a href=&quot;#React和Vue对比&quot; class=&quot;headerlink&quot; title=&quot;React和Vue对比&quot;&gt;&lt;/a&gt;React和Vue对比&lt;/h2&gt;&lt;p&gt;相同点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据驱动视图，提供响应式的视图组件&lt;/li&gt;
&lt;li&gt;都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范&lt;/li&gt;
&lt;li&gt;数据流动单向&lt;/li&gt;
&lt;li&gt;都支持服务端渲染&lt;/li&gt;
&lt;li&gt;都有支持native的方案，React的&lt;code&gt;React native&lt;/code&gt;，Vue的&lt;code&gt;weex&lt;/code&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://html-js.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习-字符串的扩展</title>
    <link href="http://html-js.site/2017/04/12/ES6%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://html-js.site/2017/04/12/ES6学习-字符串的扩展/</id>
    <published>2017-04-12T07:02:34.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。</p>
<h3 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h3><p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;\u0061&quot;</div><div class="line">// &quot;a&quot;</div></pre></td></tr></table></figure></p>
<p>但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;\uD842\uDFB7&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u20BB7&quot;</div><div class="line">// &quot; 7&quot;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;\u&#123;20BB7&#125;&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</div><div class="line">// &quot;ABC&quot;</div><div class="line"></div><div class="line">let hello = 123;</div><div class="line">hell\u&#123;6F&#125; // 123</div><div class="line"></div><div class="line">&apos;\u&#123;1F680&#125;&apos; === &apos;\uD83D\uDE80&apos;</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有6种方法可以表示一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;\z&apos; === &apos;z&apos;  // true</div><div class="line">&apos;\172&apos; === &apos;z&apos; // true</div><div class="line">&apos;\x7A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u007A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u&#123;7A&#125;&apos; === &apos;z&apos; // true</div></pre></td></tr></table></figure></p>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s = &quot;𠮷&quot;;</div><div class="line"></div><div class="line">s.length // 2</div><div class="line">s.charAt(0) // &apos;&apos;</div><div class="line">s.charAt(1) // &apos;&apos;</div><div class="line">s.charCodeAt(0) // 55362</div><div class="line">s.charCodeAt(1) // 57271</div></pre></td></tr></table></figure></p>
<p>上面代码中，汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是<code>0x20BB7</code>，UTF-16编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要4个字节储存。对于这种<code>4</code>个字节的字符，JavaScript不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6提供了<code>codePointAt</code>方法，能够正确处理<code>4</code>个字节储存的字符，返回一个字符的码点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line"></div><div class="line">s.codePointAt(0) // 134071</div><div class="line">s.codePointAt(1) // 57271</div><div class="line"></div><div class="line">s.codePointAt(2) // 97</div></pre></td></tr></table></figure></p>
<p><code>codePointAt</code>方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，<code>codePointAt</code>方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点<code>134071</code>（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。</p>
<p>总之，<code>codePointAt</code>方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt</code>方法相同。</p>
<p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line"></div><div class="line">s.codePointAt(0).toString(16) // &quot;20bb7&quot;</div><div class="line">s.codePointAt(2).toString(16) // &quot;61&quot;</div></pre></td></tr></table></figure></p>
<p>你可能注意到了，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是1，但是必须向<code>codePointAt</code>方法传入2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别32位的UTF-16字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line">for (let ch of s) &#123;</div><div class="line">  console.log(ch.codePointAt(0).toString(16));</div><div class="line">&#125;</div><div class="line">// 20bb7</div><div class="line">// 61</div></pre></td></tr></table></figure></p>
<p><code>codePointAt</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function is32Bit(c) &#123;</div><div class="line">  return c.codePointAt(0) &gt; 0xFFFF;</div><div class="line">&#125;</div><div class="line"></div><div class="line">is32Bit(&quot;𠮷&quot;) // true</div><div class="line">is32Bit(&quot;a&quot;) // false</div></pre></td></tr></table></figure></p>
<h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别<code>32</code>位的<code>UTF-16</code>字符（Unicode编号大于<code>0xFFFF</code>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String.fromCharCode(0x20BB7)</div><div class="line">// &quot;ஷ&quot;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>String.fromCharCode</code>不能识别大于0xFFFF的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>
<p>ES6提供了<code>String.fromCodePoint</code>方法，可以识别<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.fromCodePoint(0x20BB7)</div><div class="line">// &quot;𠮷&quot;</div><div class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，<code>fromCodePoint</code>方法定义在String对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p>
<h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (let codePoint of &apos;foo&apos;) &#123;</div><div class="line">  console.log(codePoint)</div><div class="line">&#125;</div><div class="line">// &quot;f&quot;</div><div class="line">// &quot;o&quot;</div><div class="line">// &quot;o&quot;</div></pre></td></tr></table></figure></p>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(text[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// " "</span></div><div class="line"><span class="comment">// " "</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "𠮷"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><p>ES5对字符串对象提供<code>charAt</code>方法，返回字符串给定位置的字符。该方法不能识别码点大于<code>0xFFFF</code>的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.charAt(0) // &quot;a&quot;</div><div class="line">&apos;𠮷&apos;.charAt(0) // &quot;\uD842&quot;</div></pre></td></tr></table></figure></p>
<p>上面代码中，charAt方法返回的是UTF-16编码的第一个字节，实际上是无法显示的。</p>
<p>目前，有一个提案，提出字符串实例的<code>at</code>方法，可以识别Unicode编号大于<code>0xFFFF</code>的字符，返回正确的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.at(0) // &quot;a&quot;</div><div class="line">&apos;𠮷&apos;.at(0) // &quot;𠮷&quot;</div></pre></td></tr></table></figure></p>
<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="string">'\u01D1'</span>.length <span class="comment">// 1</span></div><div class="line"><span class="string">'\u004F\u030C'</span>.length <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>
<pre><code>- `NFC`，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
- `NFD`，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
- `NFKC`，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
- `NFKD`，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length <span class="comment">// 1</span></div><div class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>
<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过<code>Unicode</code>编号区间判断。</p>
<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<pre><code>- **includes()：**返回布尔值，表示是否找到了参数字符串。
- **startsWith()：**返回布尔值，表示参数字符串是否在源字符串的头部。
- **endsWith()：**返回布尔值，表示参数字符串是否在源字符串的尾部。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></div><div class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数如果是小数，会被取整。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></div></pre></td></tr></table></figure></p>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)</div><div class="line"><span class="comment">// RangeError</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)</div><div class="line"><span class="comment">// RangeError</span></div></pre></td></tr></table></figure></p>
<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数<code>NaN</code>等同于0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></div></pre></td></tr></table></figure></p>
<h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></div><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></div><div class="line"></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div><div class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div></pre></td></tr></table></figure></p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</div><div class="line"><span class="comment">// '0123456abc'</span></div></pre></td></tr></table></figure></p>
<p>如果省略第二个参数，默认使用空格补全长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></div></pre></td></tr></table></figure></p>
<p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></div><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></div><div class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></div></pre></td></tr></table></figure></p>
<p>另一个用途是提示字符串格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></div><div class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样写的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(</div><div class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</div><div class="line">  <span class="string">'items in your basket, '</span> +</div><div class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</div><div class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></div><div class="line">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></div><div class="line">string text line 2`);</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure></p>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = <span class="string">`\`Yo\` World!`</span>;</div></pre></td></tr></table></figure></p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`.trim());</div></pre></td></tr></table></figure></p>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">      <span class="comment">// 传统写法为</span></div><div class="line">      <span class="comment">// 'User '</span></div><div class="line">      <span class="comment">// + user.name</span></div><div class="line">      <span class="comment">// + ' is not authorized to do '</span></div><div class="line">      <span class="comment">// + action</span></div><div class="line">      <span class="comment">// + '.'</span></div><div class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 4 = 5"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>模板字符串之中还能调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></div><div class="line"><span class="comment">// foo Hello World bar</span></div></pre></td></tr></table></figure></p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量place没有声明</span></div><div class="line"><span class="keyword">var</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</div><div class="line"><span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "Hello World"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串甚至还能嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></div><div class="line">  &lt;table&gt;</div><div class="line">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">  `).join(<span class="string">''</span>)&#125;</div><div class="line">  &lt;/table&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = [</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(tmpl(data));</div><div class="line"><span class="comment">// &lt;table&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// &lt;/table&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div></pre></td></tr></table></figure></p>
<h3 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h3><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = <span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</div><div class="line">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</div><div class="line">  &lt;% &#125; %&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置JavaScript代码，使用<code>&lt;%= ... %&gt;</code>输出JavaScript表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为JavaScript表达式字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">echo(<span class="string">'&lt;ul&gt;'</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</div><div class="line">  echo(<span class="string">'&lt;li&gt;'</span>);</div><div class="line">  echo(data.supplies[i]);</div><div class="line">  echo(<span class="string">'&lt;/li&gt;'</span>);</div><div class="line">&#125;;</div><div class="line">echo(<span class="string">'&lt;/ul&gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>这个转换使用正则表达式就行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</div><div class="line"><span class="keyword">var</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</div><div class="line"></div><div class="line">template = template</div><div class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</div><div class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</div><div class="line"></div><div class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</div></pre></td></tr></table></figure></p>
<p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script =</div><div class="line"><span class="string">`(function parse(data)&#123;</span></div><div class="line">  var output = "";</div><div class="line"></div><div class="line">  function echo(html)&#123;</div><div class="line">    output += html;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="subst">$&#123; template &#125;</span></div><div class="line"></div><div class="line">  return output;</div><div class="line">&#125;)`;</div><div class="line"></div><div class="line"><span class="keyword">return</span> script;</div></pre></td></tr></table></figure></p>
<p>将上面的内容拼装成一个模板编译函数<code>compile</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</div><div class="line">  <span class="keyword">var</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</div><div class="line"></div><div class="line">  template = template</div><div class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</div><div class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</div><div class="line"></div><div class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> script =</div><div class="line">  <span class="string">`(function parse(data)&#123;</span></div><div class="line">    var output = "";</div><div class="line"></div><div class="line">    function echo(html)&#123;</div><div class="line">      output += html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="subst">$&#123; template &#125;</span></div><div class="line"></div><div class="line">    return output;</div><div class="line">  &#125;)`;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> script;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>compile</code>函数的用法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> parse = <span class="built_in">eval</span>(compile(template));</div><div class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</div><div class="line"><span class="comment">//   &lt;ul&gt;</span></div><div class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></div><div class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></div><div class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></div><div class="line"><span class="comment">//   &lt;/ul&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert<span class="string">`123`</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">alert(<span class="number">123</span>)</div></pre></td></tr></table></figure></p>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数<code>tag</code>依次会接收到多个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p><code>tag</code>函数所有参数的实际值如下。</p>
<pre><code>- 第一个参数：`[&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;]`
- 第二个参数: 15
- 第三个参数：50
</code></pre><p>也就是说，<code>tag</code>函数实际上以下面的形式调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</div></pre></td></tr></table></figure></p>
<p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</div><div class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</div><div class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</div><div class="line">  <span class="built_in">console</span>.log(v1);</div><div class="line">  <span class="built_in">console</span>.log(v2);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// "Hello "</span></div><div class="line"><span class="comment">// " world "</span></div><div class="line"><span class="comment">// ""</span></div><div class="line"><span class="comment">// 15</span></div><div class="line"><span class="comment">// 50</span></div><div class="line"><span class="comment">// "OK"</span></div></pre></td></tr></table></figure></p>
<p>下面是一个更复杂的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="number">30</span>;</div><div class="line"><span class="keyword">var</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</div><div class="line">    result += literals[i++];</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</div><div class="line">      result += <span class="built_in">arguments</span>[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></div></pre></td></tr></table></figure></p>
<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p><code>passthru</code>函数采用rest参数的写法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</div><div class="line">    output += literals[index] + values[index];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  output += literals[index]</div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message =</div><div class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</div><div class="line"></div><div class="line">    <span class="comment">// Escape special characters in the substitution.</span></div><div class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</div><div class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</div><div class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Don't escape special characters in the template.</span></div><div class="line">    s += templateData[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></div><div class="line"><span class="keyword">var</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</div><div class="line"></div><div class="line">message</div><div class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></div></pre></td></tr></table></figure></p>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></div><div class="line"><span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的hashTemplate函数</span></div><div class="line"><span class="comment">// 是一个自定义的模板处理函数</span></div><div class="line"><span class="keyword">var</span> libraryHtml = hashTemplate<span class="string">`</span></div><div class="line">  &lt;ul&gt;</div><div class="line">    #for book in <span class="subst">$&#123;myBooks&#125;</span></div><div class="line">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</div><div class="line">    #end</div><div class="line">  &lt;/ul&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jsx<span class="string">`</span></div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;input</div><div class="line">      ref='input'</div><div class="line">      onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</div><div class="line">      defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>' /&gt;</div><div class="line">      <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></div><div class="line">   &lt;/div&gt;</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>上面的代码通过<code>jsx</code>函数，将一个<code>DOM</code>字符串转为<code>React</code>对象。你可以在<code>Github</code>找到jsx函数的<a href="https://gist.github.com/lygaret/a68220defa69174bdec5" target="_blank" rel="external">具体实现</a>。</p>
<p>下面则是一个假想的例子，通过<code>java</code>函数，在JavaScript代码之中运行Java代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">java<span class="string">`</span></div><div class="line">class HelloWorldApp &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    System.out.println(“Hello World!”); // Display the string.</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">`</div><div class="line">HelloWorldApp.main();</div></pre></td></tr></table></figure></p>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log<span class="string">`123`</span></div><div class="line"><span class="comment">// ["123", raw: Array[1]]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tag<span class="string">`First line\nSecond line`</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</div><div class="line">  <span class="comment">// "First line\\nSecond line"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，tag函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，<code>strings.raw</code>数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><p>ES6还为原生的<code>String</code>对象，提供了一个<code>raw</code>方法。</p>
<p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n5!"</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 'Hi\\u000A!'</span></div></pre></td></tr></table></figure></p>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></div><div class="line"><span class="comment">// "Hi\\n"</span></div></pre></td></tr></table></figure></p>
<p><code>String.raw</code>的代码基本如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</div><div class="line">    output += strings.raw[index] + values[index];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  output += strings.raw[index]</div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 't0e1s2t'</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<h3 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h3><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</p>
<p>举例来说，在标签模板里面可以嵌入Latex语言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></div><div class="line">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</div><div class="line">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错</div><div class="line">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错</div><div class="line"></div><div class="line">Breve over the h goes \u&#123;h&#125;ere // 报错</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于<code>Latex</code>语言来说完全是合法的，但是<code>JavaScript</code>引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将<code>\u00FF</code>和<code>\u{42}</code>当作<code>Unicode</code>字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。</p>
<p>为了解决这个问题，现在有一个提案，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</div><div class="line">  strs[<span class="number">0</span>] === <span class="literal">undefined</span></div><div class="line">  strs.raw[<span class="number">0</span>] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</div><div class="line">&#125;</div><div class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。&lt;/p&gt;
&lt;h3 id=&quot;字符的-Unicode-表示法&quot;&gt;&lt;a href=&quot;#字符的-Unicode-表示法&quot; class=&quot;headerlink&quot; title=&quot;字符的 Unicode 表示法&quot;&gt;&lt;/a&gt;字符的 Unicode 表示法&lt;/h3&gt;&lt;p&gt;JavaScript 允许采用&lt;code&gt;\uxxxx&lt;/code&gt;形式表示一个字符，其中&lt;code&gt;xxxx&lt;/code&gt;表示字符的 Unicode 码点。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;\u0061&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;quot;a&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是，这种表示法只限于码点在&lt;code&gt;\u0000&lt;/code&gt;~&lt;code&gt;\uFFFF&lt;/code&gt;之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;\uD842\uDFB7&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;quot;𠮷&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;\u20BB7&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;quot; 7&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
      <category term="es6" scheme="http://html-js.site/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>-webkit-overflow-scrolling:touch移动设备滚动回弹效果</title>
    <link href="http://html-js.site/2017/04/11/webkit-overflow-scrolling/"/>
    <id>http://html-js.site/2017/04/11/webkit-overflow-scrolling/</id>
    <published>2017-04-11T12:25:13.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><ul>
<li>auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。</li>
<li>touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */</div><div class="line"></div><div class="line">-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.&lt;/p&gt;
&lt;h3 id=&quot;值&quot;&gt;&lt;a h
    
    </summary>
    
    
      <category term="css" scheme="http://html-js.site/tags/css/"/>
    
      <category term="移动开发" scheme="http://html-js.site/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="mobile" scheme="http://html-js.site/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title>cookie</title>
    <link href="http://html-js.site/2017/04/05/cookie/"/>
    <id>http://html-js.site/2017/04/05/cookie/</id>
    <published>2017-04-05T02:59:35.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>咱们不搞一开始就一大堆理论知识介绍，怕把人讲懵了…… 咱们换一个思维方式——“从现象看本质”，先说说我们看到了什么，再从看到的现象中提出问题，最后深入寻找答案。</p>
</blockquote>
<h2 id="我们看到的-cookie"><a href="#我们看到的-cookie" class="headerlink" title="我们看到的 cookie"></a>我们看到的 cookie</h2><p>在 chrome 浏览器中打开一个网站，进入开发者模式，点击<code>Resources</code>栏 -&gt; 选择<code>cookies</code>，我们会看到如下图所示的界面：<br><img src="/images/page/cookie/1.png" alt=""><br><a id="more"></a></p>
<p>解释一下：左边栏<code>Cookies</code>下方会列举当前网页中设置过<code>cookie</code>的域都有哪些。上图中只有一个域，即“ppsc.sankuai.com”。而右侧区域显示的就是某个域下具体的 <code>cookie</code> 列表，对应上图就是<code>roundtables.hz.taeapp.com</code>域下设置的7个<code>cookie</code>。</p>
<p>在这个网页中我发了一个 Ajax 请求，request header如下图所示：<br><img src="/images/page/cookie/2.png" alt=""></p>
<p>从上图中我们会看到<code>request header</code>中自动添加了<code>Cookie</code>字段（通过设置<code>withCredentials: true</code>），<code>Cookie</code>字段的值其实就是我设置的那4个 <code>cookie</code>。这个请求最终会发送到这个服务器上，这个服务器就能从接收到的<code>request header</code>中提取那4个<code>cookie。</code></p>
<p>上面两张图展示了<code>cookie</code>的基本通信流程：设置<code>cookie</code> =&gt; <code>cookie</code>被自动添加到<code>request header</code>中 =&gt; 服务端接收到<code>cookie</code>。这个流程中有几个问题需要好好研究：</p>
<ol>
<li>什么样的数据适合放在<code>cookie</code>中？</li>
<li><code>cookie</code>是怎么设置的？</li>
<li><code>cookie</code>怎么增删查改？</li>
</ol>
<p>我们要带着这几个问题继续往下阅读。</p>
<h2 id="cookie-是怎么工作的？"><a href="#cookie-是怎么工作的？" class="headerlink" title="cookie 是怎么工作的？"></a>cookie 是怎么工作的？</h2><p>首先必须明确一点，存储<code>cookie</code>是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 <code>cookie</code> 文件夹来存放各个域下设置的<code>cookie</code>。</p>
<p>当网页要发<code>http</code>请求时，浏览器会先检查是否有相应的<code>cookie</code>，有则自动添加在<code>request header</code>中的<code>cookie</code>字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在<code>cookie</code>中”。</p>
<p>存储在<code>cookie</code>中的数据，每次都会被浏览器自动放在<code>http</code>请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在<code>cookie</code>中，其他类型的数据就不适合了。</p>
<p>但在 <code>localStorage</code> 出现之前，<code>cookie</code>被滥用当做了存储工具。什么数据都放在<code>cookie</code>中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然<code>cookie</code>标准还是做了一些限制的：每个域名下的<code>cookie</code> 的大小最大为4KB，每个域名下的<code>cookie</code>数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）。</p>
<h2 id="cookie-的格式"><a href="#cookie-的格式" class="headerlink" title="cookie 的格式"></a>cookie 的格式</h2><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>JS 原生的 API提供了获取<code>cookie</code>的方法：<code>document.cookie</code>（注意，这个方法只能获取非 HttpOnly 类型的<code>cookie</code>）。在 console 中执行这段代码可以看到结果如下图：<br><img src="/images/page/cookie/3.png" alt=""></p>
<p>打印出的结果是一个字符串类型，因为<code>cookie</code>本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 <code>key=value</code>构成，键值对之间由一个<code>分号</code>和一个<code>空格</code>隔开。</p>
<h3 id="cookie-的属性选项"><a href="#cookie-的属性选项" class="headerlink" title="cookie 的属性选项"></a>cookie 的属性选项</h3><p>每个<code>cookie</code>都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过<code>cookie</code>选项来设置的，<code>cookie</code>选项包括：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>HttpOnly</code>。在设置任一个<code>cookie</code>时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</div></pre></td></tr></table></figure></p>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p><code>expires</code>选项用来设置“<code>cookie</code> 什么时间内有效”。<code>expires</code>其实是<code>cookie</code>失效日期，<code>expires</code>必须是 <code>GMT</code> 格式的时间（可以通过 <code>new Date().toGMTString()</code>或者 <code>new Date().toUTCString()</code> 来获得）。</p>
<p>如<code>expires=Thu, 25 Feb 2016 04:18:00 GMT</code>表示<code>cookie</code>讲在2016年2月25日4:18分之后失效，对于失效的<code>cookie</code>浏览器会清空。如果没有设置该选项，则默认有效期为<code>session</code>，即会话<code>cookie</code>。这种<code>cookie</code>在浏览器关闭后就没有了。</p>
<blockquote>
<p><code>expires</code> 是 http/1.0协议中的选项，在新的http/1.1协议中<code>expires</code>已经由 <code>max-age</code> 选项代替，两者的作用都是限制<code>cookie</code> 的有效时间。<code>expires</code>的值是一个时间点（<code>cookie失效时刻= expires</code>），而<code>max-age</code> 的值是一个以秒为单位时间段（<code>cookie失效时刻= 创建时刻+ max-age</code>）。</p>
</blockquote>
<h3 id="domain-和-path"><a href="#domain-和-path" class="headerlink" title="domain 和 path"></a>domain 和 path</h3><p><code>domain</code>是域名，<code>path</code>是路径，两者加起来就构成了 <code>URL</code>，<code>domain</code>和<code>path</code>一起来限制 <code>cookie</code> 能被哪些 <code>URL</code> 访问。</p>
<p>一句话概括：某<code>cookie</code>的 <code>domain</code>为<code>baidu.com</code>, <code>path</code>为“/ ”，若请求的URL(URL 可以是js/html/img/css资源请求，但不包括 XHR 请求)的域名是“baidu.com”或其子域如“api.baidu.com”、“dev.api.baidu.com”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。</p>
<p>所以<code>domain</code>和<code>path</code>2个选项共同决定了<code>cookie</code>何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。<code>domain</code>的默认值为设置该<code>cookie</code>的网页所在的域名，<code>path</code>默认值为设置该<code>cookie</code>的网页所在的目录。</p>
<blockquote>
<p>特别说明1：<br>发生跨域xhr请求时，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下cookie也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节）</p>
<p>特别说明2：<br>domain是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix。举例说明下：如果页面域名为 www.baidu.com, domain可以设置为“www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。</p>
</blockquote>
<h3 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h3><p><code>secure</code>选项用来设置<code>cookie</code>只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 <code>secure</code> 选项的 <code>cookie</code> 才能被发送至服务器。</p>
<p>默认情况下，<code>cookie</code>不会带<code>secure</code>选项(即为空)。所以默认情况下，不管是<code>HTTPS</code>协议还是<code>HTTP</code>协议的请求，<code>cookie</code> 都会被发送至服务端。但要注意一点，secure选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 <code>cookie</code>。</p>
<p>下面我们设置一个 <code>secure</code>类型的 <code>cookie</code>：</p>
<blockquote>
<p>document.cookie = “name=huang; secure”;</p>
</blockquote>
<p>之后你就能在控制台中看到这个 cookie 了，如下图所示：<br><img src="/images/page/cookie/4.png" alt=""></p>
<blockquote>
<p>这里有个坑需要注意下：<br>如果想在客户端即网页中通过 js 去设置<code>secure</code>类型的 <code>cookie</code>，必须保证网页是<code>https</code>协议的。在<code>http</code>协议的网页中是无法设置<code>secure</code>类型cookie的。</p>
</blockquote>
<h3 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h3><p>这个选项用来设置<code>cookie</code>是否能通过 <code>js</code> 去访问。默认情况下，<code>cookie</code>不会带<code>httpOnly</code>选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个<code>cookie</code>的。当<code>cookie</code>带<code>httpOnly</code>选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个<code>cookie</code>。</p>
<p>在客户端是不能通过<code>js</code>代码去设置一个<code>httpOnly</code>类型的<code>cookie</code>的，这种类型的<code>cookie</code>只能通过服务端来设置。</p>
<p>那我们在页面中怎么知道哪些<code>cookie</code>是<code>httpOnly</code>类型的呢？看下图：<br><img src="/images/page/cookie/5.png" alt=""></p>
<p>凡是<code>httpOnly</code>类型的<code>cookie</code>，其 <code>HTTP</code> 一列都会打上√，如上图中的<code>PA_VTIME</code>。你通过<code>document.cookie</code>是不能获取的，也不能修改<code>PA_VTIME</code>的。</p>
<blockquote>
<p>——<code>httpOnly</code>与安全</p>
<p>从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问<code>cookie</code>？其实这样做是为了保障安全。</p>
<p>试想：如果任何<code>cookie</code> 都能被客户端通过<code>document.cookie</code>获取会发生什么可怕的事情。当我们的网页遭受了 <code>XSS</code>攻击，有一段恶意的<code>script</code>脚本插到了网页中。这段<code>script</code>脚本做的事情是：通过<code>document.cookie</code>读取了用户身份验证相关的 <code>cookie</code>，并将这些 <code>cookie</code> 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。</p>
</blockquote>
<h2 id="如何设置-cookie？"><a href="#如何设置-cookie？" class="headerlink" title="如何设置 cookie？"></a>如何设置 cookie？</h2><p>知道了<code>cookie</code>的格式，<code>cookie</code>的属性选项，接下来我们就可以设置<code>cookie</code>了。首先得明确一点：<code>cookie</code>既可以由服务端来设置，也可以由客户端来设置。</p>
<h3 id="服务端设置-cookie"><a href="#服务端设置-cookie" class="headerlink" title="服务端设置 cookie"></a>服务端设置 cookie</h3><p>不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个<code>ajax</code>请求，服务端都会返回<code>response</code>。而<code>response header</code>中有一项叫<code>set-cookie</code>，是服务端专门用来设置<code>cookie</code>的。如下图所示，服务端返回的<code>response header</code>中有5个<code>set-cookie</code>字段，每个字段对应一个<code>cookie</code>（注意不能将多个<code>cookie</code>放在一个<code>set-cookie</code>字段中），<code>set-cookie</code>字段的值就是普通的字符串，每个<code>cookie</code>还设置了相关属性选项。<br><img src="/images/page/cookie/6.png" alt=""></p>
<p>注意：</p>
<ul>
<li>一个<code>set-Cookie</code>字段只能设置一个<code>cookie</code>，当你要想设置多个 <code>cookie</code>，需要添加同样多的<code>set-Cookie</code>字段。</li>
<li>服务端可以设置<code>cookie</code> 的所有选项：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>HttpOnly</code></li>
</ul>
<h3 id="客户端设置-cookie"><a href="#客户端设置-cookie" class="headerlink" title="客户端设置 cookie"></a>客户端设置 cookie</h3><p>在网页即客户端中我们也可以通过<code>js</code>代码来设置<code>cookie</code>。如我当前打开的网址为<code>http://dxw.st.sankuai.com/mp/</code>，在控制台中我们执行了下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;name=Jonh; &quot;;</div></pre></td></tr></table></figure></p>
<p>查看浏览器 <code>cookie</code> 面板如下图所示，<code>cookie</code>确实设置成功了，而且属性选项 <code>domain</code>、<code>path</code>、<code>expires</code>都用了默认值。<br><img src="/images/page/cookie/7.png" alt=""></p>
<p>再执行下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie=&quot;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</div></pre></td></tr></table></figure></p>
<p>查看浏览器<code>cookie</code> 面板，如下图所示，新的<code>cookie</code>设置成功了，而且属性选项 <code>domain</code>、<code>path</code>、<code>expires</code>都变成了设定的值。<br><img src="/images/page/cookie/8.png" alt=""></p>
<p>注意：</p>
<ul>
<li>客户端可以设置<code>cookie</code> 的下列选项：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>（有条件：只有在<code>https</code>协议的网页中，客户端设置<code>secure</code>类型的 <code>cookie</code> 才能成功），但无法设置<code>HttpOnly</code>选项。</li>
</ul>
<h3 id="用-js-如何设置多个-cookie"><a href="#用-js-如何设置多个-cookie" class="headerlink" title="用 js 如何设置多个 cookie"></a>用 js 如何设置多个 cookie</h3><p>当要设置多个<code>cookie</code>时， js 代码很自然地我们会这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;name=Jonh; age=12; class=111&quot;;</div></pre></td></tr></table></figure></p>
<p>但你会发现这样写只是添加了第一个<code>cookie</code>“name=John”，后面的所有<code>cookie</code>都没有添加成功。所以最简单的设置多个<code>cookie</code>的方法就在重复执行<code>document.cookie = &quot;key=name&quot;</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;name=Jonh&quot;;</div><div class="line">document.cookie = &quot;age=12&quot;;</div><div class="line">document.cookie = &quot;class=111&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="如何修改、删除"><a href="#如何修改、删除" class="headerlink" title="如何修改、删除"></a>如何修改、删除</h2><h3 id="修改-cookie"><a href="#修改-cookie" class="headerlink" title="修改 cookie"></a>修改 cookie</h3><p>要想修改一个<code>cookie</code>，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新<code>cookie</code>时，<code>path/domain</code>这几个选项一定要旧<code>cookie</code> 保持一样。否则不会修改旧值，而是添加了一个新的<code>cookie</code>。</p>
<h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h3><p>删除一个<code>cookie</code> 也挺简单，也是重新赋值，只要将这个新<code>cookie</code>的<code>expires</code> 选项设置为一个过去的时间点就行了。但同样要注意，<code>path/domain/</code>这几个选项一定要旧<code>cookie</code> 保持一样。</p>
<h2 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a>cookie 编码</h2><p><code>cookie</code>其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当<code>cookie</code>的 <code>key</code> 和 <code>value</code> 中含有这3个特殊字符时，需要对其进行额外编码，一般会用<code>escape</code>进行编码，读取时用<code>unescape</code>进行解码；当然也可以用<code>encodeURIComponent</code>/<code>decodeURIComponent</code>或者<code>encodeURI</code>/<code>decodeURI</code>（<a href="http://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="external">三者的区别可以参考这篇文章</a>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var key = escape(&quot;name;value&quot;);</div><div class="line">var value = escape(&quot;this is a value contain , and ;&quot;);</div><div class="line">document.cookie= key + &quot;=&quot; + value + &quot;; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</div></pre></td></tr></table></figure>
<h2 id="跨域请求中-cookie"><a href="#跨域请求中-cookie" class="headerlink" title="跨域请求中 cookie"></a>跨域请求中 cookie</h2><p>之前在介绍 XHR 的一篇文章里面提过：默认情况下，在发生跨域时，cookie 作为一种 credential 信息是不会被传送到服务端的。必须要进行额外设置才可以。具体原因和如何设置可以参考我的这篇文章：<code>你真的会使用XMLHttpRequest吗</code>？</p>
<p>另外，关于跨域资源共享 <code>CORS</code>极力推荐大家阅读阮一峰老师的这篇 <code>跨域资源共享 CORS 详解</code>。</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ol>
<li>什么时候 cookie 会被覆盖：name/domain/path 这3个字段都相同的时候；</li>
<li>关于domain的补充说明（<a href="https://tools.ietf.org/html/rfc6265#section-5.2.3" target="_blank" rel="external">参考1</a>/<a href="http://erik.io/blog/2014/03/04/definitive-guide-to-cookie-domains/" target="_blank" rel="external">参考2</a>）：<ol>
<li>如果显式设置了 domain，则设置成什么，浏览器就存成什么；但如果没有显式设置，则浏览器会自动取 url 的 host 作为 domain 值；</li>
<li>新的规范中，显式设置 domain 时，如果 value 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的（注意：但目前大多数浏览器并未全部这么实现）</li>
<li>前面带点‘.’和不带点‘.’有啥区别：<ul>
<li>带点：任何 subdomain 都可以访问，包括父 domain</li>
<li>不带点：只有完全一样的域名才能访问，subdomain 不能（但在 IE 下比较特殊，它支持 subdomain 访问）</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;咱们不搞一开始就一大堆理论知识介绍，怕把人讲懵了…… 咱们换一个思维方式——“从现象看本质”，先说说我们看到了什么，再从看到的现象中提出问题，最后深入寻找答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;我们看到的-cookie&quot;&gt;&lt;a href=&quot;#我们看到的-cookie&quot; class=&quot;headerlink&quot; title=&quot;我们看到的 cookie&quot;&gt;&lt;/a&gt;我们看到的 cookie&lt;/h2&gt;&lt;p&gt;在 chrome 浏览器中打开一个网站，进入开发者模式，点击&lt;code&gt;Resources&lt;/code&gt;栏 -&amp;gt; 选择&lt;code&gt;cookies&lt;/code&gt;，我们会看到如下图所示的界面：&lt;br&gt;&lt;img src=&quot;/images/page/cookie/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
      <category term="cookie" scheme="http://html-js.site/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>ReFlux详解</title>
    <link href="http://html-js.site/2017/03/22/ReFlux%E7%BB%86%E8%AF%B4/"/>
    <id>http://html-js.site/2017/03/22/ReFlux细说/</id>
    <published>2017-03-22T07:53:49.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ps内容较多，请细心看完</p>
</blockquote>
<p>Flux作为一种应用架构（application architecture）或是设计模式（pattern），阐述的是单向数据流（a unidirectional data flow）的思想，并不是一个框架（framework）或者库（library）。</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在细说Flux之前，还是得提一下React ，毕竟Flux这个名字，是因为它才逐渐进入到大众视野。<br>React是facebook提出来的一个库，用来构建用户界面（User Interface），它的三大特点（来自官方）：</p>
<ul>
<li>JUST THE UI： 仅仅是一个View（components），可以认为是MVC中V，用来构建UI界面。</li>
<li>VIRTUAL DOM ： 虚拟dom，为的是：高性能dom渲染（利用diff算法）、组件化（向web components看齐）、多端同构（node，react native）。</li>
<li>DATA FLOW： 单向数据流（one-way data flow），指的是：一种自上而下的渲染方式（top-down rendering）。</li>
</ul>
<p>总而言之，对于一个react web应用，它的UI将会由无数个组件（react component）嵌套组合而成，它们之间存在着层级（hierarchy）关系（通过JSX的语法糖可以轻易看出），也就因此有了父组件，子组件和顶层组件的概念。</p>
<p>然而就像上述第一点所说，React仅仅是一个View，对于一个web应用，没有数据就显得毫无意义。</p>
<p>现在，假使我们通过一个WebAPI模块取得了数据，那么如何传递给React 组件（components），从而实现UI渲染呢？结合组件的层级关系，想到上述所说的第三点：自上而下的渲染，我们将数据传递给顶层组件(controller-view)，同样作为父组件的它，便可以通过组件的属性（properties）将一些有用数据传递给它的各个子组件（各取所需数据），就这样一级一级自上而下地传递下去（直到每一个叶子组件），最终，每一个组件都将得到自己渲染所需要的数据，从而完成UI的渲染。</p>
<p>那么，倘若此时数据变化了（比如：对于一个列表而言，用户点击删除按钮，删除了一条数据），我们又该如何通知各个组件进行UI更新呢？</p>
<p>有这样一种清晰的思路：<br>首先，我们应该需要一个数据存储（Store），存储着react web应用当前的状态（State），就像MVC中的Model一样。<br>然后，当用户点击删除按钮时，将会触发一个消息（Action），告诉Store数据变化了，以及哪里变化了（payload）。<br>最后，Store修改了数据之后，再将新的数据传递给最顶层组件，重新完成一次自上而下的渲染（re-render），从而更新了UI（不要过分担心性能问题，VIRTUAL DOM就是用来解决这个的）。</p>
<p>显然上述的几步，React作为一个View是不可能做到的，也正因为这样，<strong>Flux作为一种架构方案才被提出来</strong>，它的思想大体就是上述这几步，通过一个<strong>单向数据的流动</strong>，完成了UI的更新，用一张图可以表示，如下（以Facebook Flux为例）：<br><img src="/images/page/reflux/1.png" alt=""></p>
<p>当然，作为应用数据处理的模式，除了Flux，还有很多（如：传统的MVC，MVVM），只是Flux凭借其单向数据流特点，使得数据流变得简单，易于调试和追踪问题，所以更适合与React进行组合使用。<br>前面，我们就一直在说，<strong>Flux是一种架构，一种模式，并不是一个框架，也不是一个库</strong>，就像我们说MVC（VM）的概念一样，所以，遵循着Flux模式所阐述的思想自然就会出现一些库，如：Facebook Flux、Reflux、Fluxxor、Redux等等。<br>本文主要讲解的Reflux，不过在这之前还是需要先提一下Facebook Flux，从而为后面一些对比做一些铺垫。</p>
<h3 id="Facebook-Flux"><a href="#Facebook-Flux" class="headerlink" title="Facebook Flux"></a>Facebook Flux</h3><p><a href="https://github.com/facebook/flux" target="_blank" rel="external">Facebook Flux</a>，是Facebook在提出Flux架构后，给出的一个对Flux的简单实现，可以认为是Flux库的第一个范例，所以，也有人称之为Original Flux。<br>Facebook Flux中引入了四个概念： Dispatcher、 Actions、Stores、Views（Controller-Views），而它们之间的关系就如同上面的那张图所描述的一样，构成了一个单向数据流的闭环，简化版如下：<br><img src="/images/page/reflux/2.png" alt=""><br>接下来，将以官方的TodoMVC Demo为例，来说明它们各自的作用，以及它们之间是如何配合工作的？（PS：建议读者将源代码clone下来，边看边调试）<br><img src="/images/page/reflux/3.png" alt=""></p>
<h4 id="Views-and-Controller-Views"><a href="#Views-and-Controller-Views" class="headerlink" title="Views and Controller-Views"></a>Views and Controller-Views</h4><p>Facebook Flux中所指的Views，其实就是React Components，用作UI渲染，而相对特别的，Controller-Views指的则是顶层React Component，除了UI渲染外，它还负责接收来自Store变化的数据，并传递给它的Child Component（即Controller-View -&gt; Child Views），用于子View的渲染。<br>在这个例子中，TodoApp就是一个Controller-View，它监听到TodoStore的数据变化后，便会重新从TodoStore中获取数据，然后通过调用组件setState()方法，触发render()方法的执行，从而得到UI的更新（自上而下的渲染）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 从TodoStore中获取数据</div><div class="line">function getTodoState() &#123;</div><div class="line">  return &#123;</div><div class="line">    allTodos: TodoStore.getAll(),</div><div class="line">    areAllComplete: TodoStore.areAllComplete()</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var TodoApp = React.createClass(&#123;</div><div class="line"></div><div class="line">  componentDidMount: function() &#123;</div><div class="line">	// TodoApp监听TodoStore的数据变化</div><div class="line">    TodoStore.addChangeListener(this._onChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">	return (</div><div class="line">		&lt;div&gt;&#123;/* 此处代码省去 */&#125;&lt;/div&gt;</div><div class="line">	);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  _onChange: function() &#123;</div><div class="line">	// 重新获取TodoStore的数据，并通过调用setState，触发re-render</div><div class="line">    this.setState(getTodoState());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Stores"><a href="#Stores" class="headerlink" title="Stores"></a>Stores</h3><p>Facebook Flux中的Stores，作为数据存储的模块，类似于MVC中的Model，它负责接收Dispatcher分发过来的actions，针对不同的actionType，对数据就进行不同的操作（如：增删改查），最后再通知View，数据变化了，需要进行UI更新。</p>
<p>在这个例子中，TodoStore通过变量_todos变量存储着整个应用的数据（一个列表），并通过AppDispatcher（Dispatcher实例）注册回调，来接收不同类型的Action指令，进而执行不同的数据操作（mutate data），最后通知TodoApp View数据改变，需要更新UI（re-render）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// 数据存储（一个列表）</div><div class="line">var _todos = &#123;&#125;;</div><div class="line"></div><div class="line">// 操作数据的函数</div><div class="line">function create(text) &#123;/*此处代码省去*/&#125;</div><div class="line">function update(id, updates) &#123;/*此处代码省去*/&#125;</div><div class="line">function destroy(id) &#123;</div><div class="line">  delete _todos[id];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收分发过来的Action</div><div class="line">AppDispatcher.register(function(action) &#123;</div><div class="line">  var text;</div><div class="line">  </div><div class="line">  // 判断Action类型，采取不同的数据操作</div><div class="line">  switch(action.actionType) &#123;</div><div class="line">  </div><div class="line">	// 新增</div><div class="line">    case TodoConstants.TODO_CREATE:</div><div class="line">      text = action.text.trim();</div><div class="line">      if (text !== &apos;&apos;) &#123;</div><div class="line">        create(text);  // 创建数据，并存储</div><div class="line">        TodoStore.emitChange(); // 通知TodoApp数据变化，需要更新UI</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">      </div><div class="line">	// 更新</div><div class="line">    case TodoConstants.TODO_UPDATE_TEXT:/*此处代码省去*/</div><div class="line">	  break;</div><div class="line">	  </div><div class="line">	// 删除</div><div class="line">    case TodoConstants.TODO_DESTROY:/*此处代码省去*/</div><div class="line">	  break;</div><div class="line">	  </div><div class="line">   /*此处省去部分代码*/</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Facebook Flux中，Dispatcher起到了一个中央枢纽（Central Hub）的角色，它存储着一张Stores列表清单，并且负责Actions的分发工作，即Action的一旦触发，Dispatcher将会通知列表清单上的<strong>所有的Stores</strong>，每一个Store则选择性地针对该Action进行特定处理（或者不处理）。<br>在一个应用中，Dispatcher实例只允许有一个（Single），也就是说它将作为一个单例而存在。<br>在这个例子中，AppDispatcher就是这样一个单例，我们在TodoStores通过AppDispatcher.register()注册回调（见上段代码），来接收不同类型的Actions（消息订阅），在TodoActions里通过AppDispatcher.dispatch()执行不同Actions的分发（消息发布），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var TodoActions = &#123;</div><div class="line">  // 新增Action</div><div class="line">  create: function(text) &#123;</div><div class="line">    AppDispatcher.dispatch(&#123;  // 通知TodoStore对数据进行修改（带有Action类型和关联数据）</div><div class="line">      actionType: TodoConstants.TODO_CREATE, // Action类型：create</div><div class="line">      text: text  // 传递给TodoStore的数据</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  // 更新Action</div><div class="line">  updateText: function(id, text) &#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      actionType: TodoConstants.TODO_UPDATE_TEXT, // Action类型：update</div><div class="line">      id: id,</div><div class="line">      text: text</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  // 删除Action</div><div class="line">  destroy: function(id) &#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      actionType: TodoConstants.TODO_DESTROY, // Action类型：destroy</div><div class="line">      id: id</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  /*此处省去部分代码*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>Facebook Flux中的有一个概念叫做Action Creator，可以将它理解为一个方法（即helper method），专门用来创建某种类型的Action。<br>上一段代码中，TodoActions模块就提供了这些helper methods（或者叫做Action Creators），如：<br>TodoActions.create(text)<br>TodoActions.updateText(id, text)<br>TodoActions.destroy(id)<br>…<br>上述每一个方法在内部，都定义了自己的常量类型（actionType），并且将接收的参数作为数据（payload），从而封装成一个完整的Action（即actionType + payload = Action）。<br>最后，再统一通过调用Dispatcher.dispatch()将特定的Action以消息的形式分发出去（即传递给Stores），Stores在得到Action后，便可以通过Action.actionType来判定采取某种操作（或者忽略这个Action），而执行操作时需要用到的数据则来自Action.payload。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Facebook Flux中提出的这四个概念，承担着各自角色，通过互相协作，形成了一个单向数据流的闭环。<br>——【推荐大家看下这篇文章<a href="https://code-cartoons.com/a-cartoon-guide-to-flux-6157355ab207" target="_blank" rel="external">《A cartoon guide to Flux》</a>，生动形象地描述了这几个角色。】<br>说完了Facebook Flux，让我们静静思考一下，存在的不足：<br>倘若，有一个单页面应用，程序中就可能存在N个store，每个store都会监听1~N个action，代码就会像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// storeA.js</div><div class="line">Dispatcher.register(function (action) &#123;</div><div class="line">	switch(action.actionType) &#123;</div><div class="line">		case &apos;actionA&apos;: break;</div><div class="line">		case &apos;actionB&apos;: break;</div><div class="line"></div><div class="line">		/* ... 1~N个action */</div><div class="line">		</div><div class="line">		case &apos;actionN&apos;: break;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// storeB.js</div><div class="line">Dispatcher.register(function () &#123;</div><div class="line">	// 同上</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/* ... */</div><div class="line">/* ... 1~N个store */</div><div class="line">/* ... */</div><div class="line"></div><div class="line">// storeN.js</div><div class="line">Dispatcher.register(function () &#123;</div><div class="line">	// 同上</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>假使此时，触发了一个actionX，那么storeA~storeB的通过Dispatcher.register()注册的回调函数会按注册顺序依次被触发(无一例外)，也就是说每个store都会得到actionX通知，唯一不同的可能就是：每个store模块，会通过各自的switch语句进行判断，有的对actionX做处理，有的则不处理（忽略），那么问题来了：</p>
<p>『既然有些store对actionX不需要处理，那么它们注册的回调执行是否有必要？毕竟是函数执行是有开销的，如果有1000个store对actionX不”感冒”的的话，会不会很浪费资源？』<br>分析下这个问题：Facebook Flux是以Dispatcher（发布者）作为消息中枢，所有的Action消息都会统一从这里分发出去，广播给所有的Store（订阅者），也就是说：发布者（Dispatcher）和订阅者（Stores）之间存在着一对多的关系，而事实上Actions（消息）和Stores（订阅者）之间却存在着一个多对多的关系，如下图：<br><img src="/images/page/reflux/4.png" alt=""></p>
<p>这样的矛盾，就使得，每一个Store不得不在自己的回调函数里通过Switch语句，来判断当前Action的类型，来决定要不要进行处理，那么暂且抛开性能不说，显然，这样写法，却显得繁重且不够优雅。<br>于是，接下来，看看Reflux在Facebook Flux的基础之上，做了那些优化？</p>
<h2 id="Reflux"><a href="#Reflux" class="headerlink" title="Reflux"></a>Reflux</h2><p><a href="https://github.com/reflux/refluxjs" target="_blank" rel="external">Reflux</a>，是另一个实现Flux模式的库，旨在使整个应用架构变得更加简单。<br>准确地说，Reflux是由Facebook Flux演变而来（inspired by Facebook Flux），可以说是它的一个进化版本，自然而言就会拿两者进行比较：<a href="https://github.com/reflux/refluxjs#comparing-refluxjs-with-facebook-flux" target="_blank" rel="external">详见这里</a>。<br>简要概括一下重点，就是：</p>
<p>1.Reflux保留了Facebook Flux中原有的三个概念：Actions、Stores、Views（Controller-Views），去除了Dispatcher，如果要用一张图表示的话，就是这样：<br><img src="/images/page/reflux/5.png" alt=""></p>
<p>此时会有人问：没有了消息中枢（Dispatcher），消息Actions如何发布出去，并传递到Stores呢？<br>答：在Reflux中，每一个Action本身就是一个Publisher（消息发布者），即自带了消息发布功能；而每一个Store除了作为数据存储之外，它还是一个Subscriber，或者叫做Listener（消息订阅者），自然就可以通过监听Action，来获取到变化的数据。</p>
<p>2.Store之间可以互相监听</p>
<h2 id="这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：子页面Store数据变化后，需要通知到父页面Store进行相应修改的情况。"><a href="#这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：子页面Store数据变化后，需要通知到父页面Store进行相应修改的情况。" class="headerlink" title="这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：子页面Store数据变化后，需要通知到父页面Store进行相应修改的情况。"></a>这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：<strong>子页面Store数据变化后，需要通知到父页面Store进行相应修改</strong>的情况。</h2><p>回顾上一节中，对于Facebook Flux的思考，所遗留的问题点，在Reflux中是否解决了呢？<br>答案是：肯定的。<br>这里先简单说明下：<br>前面讲到Actions和Stores（消息订阅者）间本身就存在着多对多的关系，而作为Publisher（消息发布者），<br>在Facebook Flux中只有一个，即Dispatcher，所以，不得不在消息发布时，通过在payload中添加actionType字段来区分消息类型，且Store也因此不得不在回调函数中用Switch语句进行判断actionType处理。<br>而在Reflux中，由于每一个Action都是一个Publisher，且具有特定的含义（actionType），即多个Publisher对应于多个Subscriber（或叫做Listener），Store便可以有目的性地选择订阅想监听的Action，而不是监听所有的Action，再通过Switch语句进行筛选；另外，Action（消息）的发布，也只会通知给之前有订阅过的Store，而不是所有Store，所以并不会造成任何资源浪费。<br>归结一点，就是Reflux将Dispatcher的功能合并到Action中去，使得每一个Action都具有了消息发布的功能，可以直接被Store所监听（即listenable）。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>无论是从具体的用法，还是从源码的架构来看，<strong>Reflux本质上可以理解为一个PubSub库</strong>。<br>可以用一张具体的图来表现这一说法，如下：<br><img src="/images/page/reflux/6.png" alt=""></p>
<p>从图中可以看出，Actions、Stores和Views在Reflux中分别承担着消息发布订阅模式中的一个或多个角色，即：发布者（Publisher）或者 订阅者（Subscriber/Listener），也正是基于这样的角色扮演，才使得它能够实现作为Flux所应该具有的单向数据流特性（图中红线部分）。<br>总结一下：</p>
<h4 id="Reflux单向数据流的实现，是完全基于PubSub设计模式的。"><a href="#Reflux单向数据流的实现，是完全基于PubSub设计模式的。" class="headerlink" title="Reflux单向数据流的实现，是完全基于PubSub设计模式的。"></a>Reflux单向数据流的实现，是完全基于PubSub设计模式的。</h4><p>Action，Store和View三者的角色分配以及分工合作，如下：</p>
<ul>
<li>Action 是一个Publisher，负责消息的分发，一般是由用户行为（User Interaction），或是Web API触发。</li>
<li>Store 不仅是一个Publisher，还是一个Subscriber（或者叫做Listener），作为Subscriber，负责监听Action的触发；作为Publisher，则负责通知View更新UI。</li>
<li>View 是一个Subscriber，负责监听Store的数据变化，做到及时更新UI。</li>
</ul>
<p>既然Reflux中的对象不是Publisher就是Subscriber/Listener，那么代码是如何组织的呢？<br>答：Reflux抽取出两个模块：PublisherMethods 和 ListenerMethods，顾名思义，这两个集合分别存储着一个对象作为Publisher和Listener所应该具有的方法。</p>
<p>比如：<br>PublisherMethods中包括：trigger、triggerAsync等消息发布方法。<br>ListenerMethods中就包括listenTo、listenToMany等消息订阅方法。<br>具体的细节，感兴趣的同学可以看一下源码，以及这篇文章《<a href="http://blog.krawaller.se/posts/the-reflux-data-flow-model/" target="_blank" rel="external">The Reflux data flow model</a>》详细介绍了Reflux与PubSub的关系。</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>这一节的主要目的是：通过代码示例和应用场景，尽可能地讲解Reflux每个API的全貌，以及将代码如何写得更简洁优雅？</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>在Reflux中，因为没有了Action Creator的概念，所以，Action的创建都是通过统一的API：Reflux.createAction()或者Reflux.createActions()来实现。</p>
<p>1.通过Reflux.createAction()创建单个Action，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 拥有配置</div><div class="line">var action = Reflux.createAction(&#123;</div><div class="line">    actionName: &apos;addItem&apos;,  // 其实这个actionName并没有什么用，可不传</div><div class="line">    asyncResult: true,</div><div class="line">    sync: false,</div><div class="line">    children: [&apos;success&apos;]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 简化</div><div class="line">var action = Reflux.createAction(&apos;addItem&apos;)</div><div class="line"></div><div class="line">// 或者匿名</div><div class="line">var addItemAction = Reflux.createAction();</div></pre></td></tr></table></figure></p>
<p>注意：Reflux.createAction()的返回值是一个特殊的对象 — 函数（functor），这样的设计其实是为了方便Action的触发，显得更加函数化编程(FRP) ，就像下面这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">addItemAction(&#123;a: 1&#125;);</div><div class="line">action(&apos;hello world&apos;, &apos;Lovesueee&apos;);</div></pre></td></tr></table></figure></p>
<p>action创建的时候，可以进行参数的配置，具体的参数意义如下：<br>sync： 设置为true，指定action的默认触发方式为同步<br>children： 用于创建子Action（主要是用在异步操作的时候，后面会讲到）</p>
<h2 id="asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）"><a href="#asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）" class="headerlink" title="asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）"></a>asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）</h2><p>2.通过Reflux.createActions()创建多个Action，即Actions集合，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">// 个别action配置</div><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &#123;</div><div class="line">	deleteItem: &#123;</div><div class="line">		asyncResult: true,</div><div class="line">		children: [&apos;success&apos;],</div><div class="line">	&#125;,</div><div class="line">	updateItem: &#123;...&#125;</div><div class="line">&#125;]);</div><div class="line"></div><div class="line">// 也可以这样</div><div class="line">var actions = Reflux.createActions(&#123;</div><div class="line">	addItem: &#123;&#125;,</div><div class="line">	deleteItem: &#123;</div><div class="line">		asyncResult: true,</div><div class="line">		children: [&apos;success&apos;]</div><div class="line">	&#125;,</div><div class="line">	updateItem: &#123;...&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意：Reflux.createActions()返回的是一个普通的对象，即Actions集合，所以Action触发时，需要指定actionName，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">actions.addItem(&#123;...&#125;);</div><div class="line">actions.deleteItem();</div></pre></td></tr></table></figure></p>
<h2 id="一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux-createActions-一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。"><a href="#一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux-createActions-一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。" class="headerlink" title="一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux.createActions()一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。"></a>一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux.createActions()一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。</h2><p>之前就提到，Action作为一个Publisher，会拥有PublisherMethods集合里提供的一系列方法，这里统一举例说明：<br>listen：Action消息订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction();</div><div class="line"></div><div class="line">addAction.listen(function (url) &#123;</div><div class="line">	// 默认上下文this是addAction</div><div class="line">	$.ajax(url).done(function () &#123;</div><div class="line">		// todo: save to store</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction(&apos;/xxx/add&apos;);</div></pre></td></tr></table></figure></p>
<hr>
<p>trigger 同步触发Action消息，在触发具体的消息之前，首先会先执行preEmit和shouldEmit回调。<br>preEmit返回值(非undefined)将作为shouldEmit函数的入参，用于修改payload<br>shouldEmit的返回值(true or false)，将作为是否真正触发消息的标志<br>举几个例子说明下，preEmit和shouldEmit的使用，如下：<br>preEmit用于异步请求，下面两种方法是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions(&#123;</div><div class="line">	add: &#123;</div><div class="line">		asyncResult: true,</div><div class="line">		preEmit: function (url) &#123;</div><div class="line">			$.ajax(url)</div><div class="line">				.done(this.completed)</div><div class="line">				.fail(this.failed);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">// 等价于</div><div class="line">var actions = Reflux.createActions(&#123;</div><div class="line">	add: &#123;</div><div class="line">		asyncResult: true</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">actions.add.listen(function(url) &#123;</div><div class="line">	$.ajax(url)</div><div class="line">		.done(this.completed)</div><div class="line">		.fail(this.failed)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>preEmit用于修改payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;takePhoto&apos;]);</div><div class="line"></div><div class="line">// 映射</div><div class="line">var maps = &#123;</div><div class="line">	&apos;photo&apos;: &#123;</div><div class="line">		maxSize: 1000     // 从相册获取</div><div class="line">	&#125;,</div><div class="line">	&apos;camera&apos;: &#123;           // 拍照</div><div class="line">		maxSize: 2000,</div><div class="line">		maxSelect: 10</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">actions.takePhoto.preEmit = function (type) &#123;</div><div class="line">	return maps[type] || maps[&apos;photo&apos;];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">actions.takePhoto.listen(function (options) &#123;</div><div class="line">	// do ajax</div><div class="line">	console.log(options);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">actions.takePhoto(&apos;photo&apos;);</div><div class="line">// 或者</div><div class="line">// actions.takePhoto(&apos;camera&apos;);</div></pre></td></tr></table></figure></p>
<p>shouldEmit的使用（防止action的频繁触发）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var requesting = false;</div><div class="line">var actions = Reflux.createActions([&apos;submit&apos;]);</div><div class="line"></div><div class="line">actions.submit.shouldEmit = function () &#123;</div><div class="line">	return !requesting;</div><div class="line">&#125;</div><div class="line"></div><div class="line">actions.submit.listen(function (url) &#123;</div><div class="line"></div><div class="line">	requesting = true;</div><div class="line">	</div><div class="line">	$.ajax(url).done(function () &#123;</div><div class="line">		// success</div><div class="line">	&#125;).fail(function () &#123;</div><div class="line">		// error</div><div class="line">	&#125;).always(function () &#123;</div><div class="line">		requesting = false;</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 点击按钮</div><div class="line">$(&apos;#btn&apos;).click(function () &#123;</div><div class="line">	actions.submit(&apos;url/submit&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<p>promise: 语法糖，用于简写异步Action，下面两种方法是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	children: [&apos;completed&apos;, &apos;failed&apos;] // 等价于 asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction.listen(function (url) &#123;</div><div class="line">	var me = this;</div><div class="line">	$.ajax(url).done(function (data) &#123;</div><div class="line">		me.completed(data);</div><div class="line">	&#125;).fail(function () &#123;</div><div class="line">		me.failed();</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等价于</div><div class="line">addAction.listen(function (url) &#123;</div><div class="line">	this.promise($.ajax(url));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction(&apos;/url/add&apos;);</div></pre></td></tr></table></figure></p>
<p>listenAndPromise: 是上述两个方法listen和promise方法的结合，做了两件事情：消息订阅和异步回调。<br>比如上面的例子，就可以这样简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">addAction.listenAndPromise(function(url) &#123;</div><div class="line">    return $.ajax(url);    // 注意：返回promise对象</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="triggerAsync-异步触发Action消息（而trigger同步触发消息），类似于setTimeout-function-action-0-。"><a href="#triggerAsync-异步触发Action消息（而trigger同步触发消息），类似于setTimeout-function-action-0-。" class="headerlink" title="triggerAsync: 异步触发Action消息（而trigger同步触发消息），类似于setTimeout(function () {action();}, 0)。"></a>triggerAsync: 异步触发Action消息（而trigger同步触发消息），类似于setTimeout(function () {action();}, 0)。</h2><p>triggerPromise 触发Action消息，可以通过返回的promise将异步请求的数据直接带回，而不需要经过Store。<br>改写上面的例子，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction.listenAndPromise(function(url) &#123;</div><div class="line">    return $.ajax(url);    // 注意：返回promise对象</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 触发消息，监听异步子action的成功与失败</div><div class="line">// action这里可以获取到数据，</div><div class="line">addAction.triggerPromise(&apos;/url/add&apos;).then(function (data) &#123;</div><div class="line">	console.log(data);</div><div class="line">&#125;, function () &#123;</div><div class="line">	console.log(&apos;failed&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<p>最后再说说，子Action的概念，其实之前都用到了，主要是用于异步请求，成功和失败回调的执行，这里简单说明一下：<br>在利用Reflux.createAction创建Action之初，可以通过下面的两种方式创建子Action:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等价于</div><div class="line"></div><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	children: [&apos;completed&apos;, &apos;failed&apos;]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction-completed和addAction-failed访问。"><a href="#在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction-completed和addAction-failed访问。" class="headerlink" title="在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction.completed和addAction.failed访问。"></a>在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction.completed和addAction.failed访问。</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store作为数据存储中心，且因为介于Actions和Views之间，所以同时承担着Publisher（消息发布者）和Subscriber（消息订阅者）两种角色。<br>Reflux中，Store的创建同样是通过提供的API：Reflux.createStore()，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var action = Reflux.createAction();</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		// 存储数据</div><div class="line">		this.data = &#123;&#125;;</div><div class="line">			</div><div class="line">		// Action监听</div><div class="line">		this.listenTo(action, this._onAction);</div><div class="line">		// 或者</div><div class="line">		// this.listenTo(action, &apos;_onAction&apos;);</div><div class="line">		// 或者</div><div class="line">		// action.listen(this._onAction);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	_onAction: function (msg) &#123;</div><div class="line">		console.log(msg);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">action(&apos;hello world&apos;);	// 触发动作</div></pre></td></tr></table></figure></p>
<h2 id="不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储-和Action的监听。"><a href="#不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储-和Action的监听。" class="headerlink" title="不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储 和Action的监听。"></a>不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储 和Action的监听。</h2><p>在创建Store时，我们可以通过传递一个特殊的字段mixins，它的功能就有点类似于React Component中的mixins。<br>在mixin中，对于几个特殊方法：init, preEmit, shouldEmit会进行特殊处理（组合），保证mixins里面的方法都会被执行而，对于其他自定义方法，有一定的覆盖规则，比如，下面的例子中myMethod方法的覆盖优先级就是：store &gt; mixin3 &gt; mixin2 &gt; mixin。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">var mixin = &#123;</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;mixin:init&apos;)</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin.myMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var mixin2 = &#123;</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;mixin2:init&apos;)</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin2.myMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var mixin3 = &#123;</div><div class="line">	mixins: [mixin2],</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;mixin3:init&apos;)</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin3.myMethod&apos;);</div><div class="line">	&#125;,</div><div class="line">	otherMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin3.otherMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	mixins: [mixin, mixin3],</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;store:init&apos;);</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;store:myMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">store.myMethod();</div><div class="line"></div><div class="line">// mixin:init</div><div class="line">// mixin2:init</div><div class="line">// mixin3:init</div><div class="line">// store:init</div><div class="line">// store:myMethod</div></pre></td></tr></table></figure></p>
<hr>
<p>再从PubSub的角度说说Store：<br>作为消息的发布者，拥有着和Action一样的能力，即拥有PublisherMethods集合的所有方法；同时作为消息的订阅者，用来监听Action的触发（或其他Store的改变），从而改变自身数据，Store还拥有ListenerMehthods集合提供的方法。<br>这里重点说一下，Store作为消息订阅者这个角色，拥有的几个比较重要的方法：</p>
<p>listenTo: 监听指定的listenable的变化，从而执行回调（这里的listenable可以是Action，也可以是Store）<br>(注意：reflux中，Store之间是可以监听的，但是不可以互相监听哦，避免死循环（circular loop）)<br>举例几个例子，说明：<br>Store监听Action<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&apos;add&apos;);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.data = &#123;</div><div class="line">			flag: false</div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">	getInitialState: function () &#123;</div><div class="line">		return this.data;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">store.listenTo(addAction, function (flag) &#123;</div><div class="line">	this.data.flag = flag;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction(true);</div></pre></td></tr></table></figure></p>
<p>Store监听其他Store（设置listenTo第三个回调，通过调用被监听Store的getInitialState方法获取其初始值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var storeA = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.data = &#123;</div><div class="line">			a: 1</div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">	getInitialState: function () &#123;</div><div class="line">		return this.data;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var storeB = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.data = &#123;</div><div class="line">			b: 2</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">storeB.listenTo(storeA, function (a) &#123;</div><div class="line">	this.data.a = a;</div><div class="line">&#125;, function (data) &#123;</div><div class="line">	// storeB获取storeA的初始值</div><div class="line">	this.data.a = data.a;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(storeB); // storeB.data =&gt; &#123;a: 1, b: 2&#125;</div><div class="line"></div><div class="line">storeA.trigger(3);</div><div class="line"></div><div class="line">console.log(storeB); // storeB.data =&gt; &#123;a: 3, b: 2&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>listenToMany: 监听指定的listenables（对象集合）变化，从而执行对应的回调（这里的listenables是一个对象，它的每一个值可以是action，也可以是store）<br>通常会这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.items = [];</div><div class="line">		this.listenToMany(actions);</div><div class="line">	&#125;,</div><div class="line">	onAddItem: function (item) &#123;</div><div class="line">		this.items.push(item);</div><div class="line">	&#125;,</div><div class="line">	onDeleteItem: function (item) &#123;</div><div class="line">		var items = this.items;</div><div class="line">		</div><div class="line">		items.forEach(function (val, index) &#123;</div><div class="line">			if (val === item) &#123;</div><div class="line">				items.splice(index, 1);</div><div class="line">				// todo: break</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">actions.addItem(1);</div><div class="line">actions.addItem(2);</div><div class="line"></div><div class="line">console.log(store); // store.items =&gt; [1, 2]</div><div class="line"></div><div class="line">actions.deleteItem(1);</div><div class="line"></div><div class="line">console.log(store); // store.items =&gt; [2]</div></pre></td></tr></table></figure></p>
<p>当一个store监听listenables对象集合（即多个监听对象，比如：多个action）时，实际上做的事情也还是单个消息订阅store.listenTo(actionName, onActionName)，但是这里有一个约定（或者叫做映射关系），以上面的两个action为例:</p>
<p><strong>actionName    onActionName</strong><br>addItem        onAddItem<br>deleteItem    onDeleteItem</p>
<p>actionName 对应的回调就是 on + actionName(驼峰写法)<br>然后Reflux还做了一些容错处理，如果你不按照这个约定（即命名不规范）的话，它会这样获取需要注册的回调：<br>以名为addItemaction为例，它的callback依次会取：<br>this.onAddItem -&gt; this.addItem -&gt; undefined（不注册回调）<br>自然而然，涉及到listenTo方法就会想起上面说的它的第三个参数defaultCallback用来初始化，那么在listenToMany方法对此就有这样的约定（或者叫做映射关系）：<br>以名为addItemaction为例（一般是store之间才会使用，且很少使用），它的defaultCallback依次会取：</p>
<h2 id="this-onAddItemDefault-gt-this-addItemDefault-gt-undefined（没有初始化回调）"><a href="#this-onAddItemDefault-gt-this-addItemDefault-gt-undefined（没有初始化回调）" class="headerlink" title="this.onAddItemDefault -&gt; this.addItemDefault -&gt; undefined（没有初始化回调）"></a>this.onAddItemDefault -&gt; this.addItemDefault -&gt; undefined（没有初始化回调）</h2><p>这里还需要再提起一次，子Action的概念，对于下面这段代码：<br>之前会这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.listenTo(addAction.completed, &apos;onAddCompleted&apos;);</div><div class="line">		this.listenTo(addAction.failed, &apos;onAddFailed&apos;);</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	onAddCompleted: function (data) &#123;</div><div class="line">		console.log(&apos;completed: &apos;, data);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	onAddFailed: function () &#123;</div><div class="line">		console.log(&apos;failed&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果用listenToMany方法来做的话，就可以这样简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.listenToMany(&#123;add: addAction&#125;); // 注意：参数是一个对象</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	onAddCompleted: function (data) &#123;</div><div class="line">		console.log(&apos;completed: &apos;, data);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	onAddFailed: function () &#123;</div><div class="line">		console.log(&apos;failed&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>也就是说，listenToMany方法，不但关联了action，还会关联它的子action，即addAction.completed和addAction.failed，这里就又有一个约定（或者叫做映射关系）：</p>
<p><strong>actionName    onActionName    childActionName    onChildActionName</strong><br>add    onAdd    addCompleted / addFailed    onAddCompleted / onAddFailed</p>
<h2 id="即：on-主action名-子action名（驼峰）"><a href="#即：on-主action名-子action名（驼峰）" class="headerlink" title="即：on + 主action名 + 子action名（驼峰）"></a>即：on + 主action名 + 子action名（驼峰）</h2><p>然而，在利用Reflux.createStore()创建之初，我们可以利用更简洁的一种方式，对Store和Actions进行关联。<br>之前是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.listenToMany(actions); // 关联actions</div><div class="line">	&#125;,</div><div class="line">	onAddItem: function () &#123;</div><div class="line">		// todo: add</div><div class="line">	&#125;,</div><div class="line">	onDeleteItem: function () &#123;</div><div class="line">		// todo: delete</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>现在可以通过listenables字段来关联：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	listenables: actions  // 关联actions</div><div class="line">	init: function () &#123;</div><div class="line">		// init</div><div class="line">	&#125;,</div><div class="line">	onAddItem: function () &#123;</div><div class="line">		// todo: add</div><div class="line">	&#125;,</div><div class="line">	onDeleteItem: function () &#123;</div><div class="line">		// todo: delete</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是一种快捷方式，其实内部原理就是store在创建的时候，调用了listenToMany方法。<br>注意：listenables这里可以是actions组成的数组，如：[actions1, actions2]，就相当于多调用几次listenToMany方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">this.listenToMany(actions1); </div><div class="line">this.listenToMany(actions2);</div></pre></td></tr></table></figure></p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>对于View，只需在React Component里的生命周期函数里，负责监听Store的变化，并及时通过调用setState（）方法更新UI即可，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var myStore = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		// init</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">	</div><div class="line">	componentDidMount() &#123;</div><div class="line">		this.unsubscribe = myStore.listen(this.onChange);</div><div class="line">	&#125;</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">        this.unsubscribe(); // 注意：在组件销毁时，一定要解除监听</div><div class="line">    &#125;</div><div class="line">	onChange(data) &#123;</div><div class="line">		this.setState(data); // re-render</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述方式，是通过myStore.listen()来进行消息订阅的，而实际上，View本身并没有消息订阅的能力，所以Reflux提供了一个mixin，叫做Reflux.ListenerMixin。<br>它的实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = _.extend(&#123;</div><div class="line">    componentWillUnmount: ListenerMethods.stopListeningToAll</div><div class="line">&#125;, ListenerMethods);</div></pre></td></tr></table></figure></p>
<p>作为React Component的一个mixin，它其实做了两件事情：<br>给View添加ListenerMethods集合里的方法，使View具备了消息订阅的能力。<br>在组件销毁componentWillUnmount生命周期方法里，对之前监听的Action自动解绑。<br>所以，上述代码可以简化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import Reflux from &apos;reflux&apos;;</div><div class="line">import ReactMixin from &apos;react-mixin&apos;;</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">	</div><div class="line">	componentDidMount() &#123;</div><div class="line">		this.listenTo(myStore, this.onChange); // View本身具备了订阅的能力</div><div class="line">	&#125;</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">       // nothing 无需手动解除监听</div><div class="line">    &#125;</div><div class="line">	onChange(data) &#123;</div><div class="line">		this.setState(data); // re-render</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ES6 mixin写法</div><div class="line">ReactMixin.onClass(MyComponent, Reflux.ListenerMixin);</div></pre></td></tr></table></figure></p>
<p>然而还有更简单的写法，就是通过Reflux.connect()来写，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import Reflux from &apos;reflux&apos;;</div><div class="line">import ReactMixin from &apos;react-mixin&apos;;</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">	</div><div class="line">	componentDidMount() &#123;</div><div class="line">		// nothing 无需手动监听</div><div class="line">	&#125;</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">       // nothing 无需手动解除监听</div><div class="line">    &#125;</div><div class="line">	onChange(data) &#123;</div><div class="line">	   // noting 无需手动setState</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ES6 mixin写法</div><div class="line">ReactMixin.onClass(MyComponent, Reflux.connect(myStore));</div></pre></td></tr></table></figure></p>
<p>原理是这样的，React.connect(myStore)返回的一个mixin，这个mixin内部在做了类似下面的事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">this.listenTo(myStore, (data) =&gt; &#123;</div><div class="line">	this.setState(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>所以，这才帮我们省去了手动监听，手动删除监听，还有手动触发UI更新这三步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ps内容较多，请细心看完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flux作为一种应用架构（application architecture）或是设计模式（pattern），阐述的是单向数据流（a unidirectional data flow）的思想，并不是一个框架（framework）或者库（library）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
      <category term="reflux" scheme="http://html-js.site/tags/reflux/"/>
    
  </entry>
  
</feed>
